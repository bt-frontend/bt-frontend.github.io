{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modern Frontend Documentation","text":"<p>Welcome to the Modern Frontend Documentation! This guide covers best practices, project setup, architecture, and development techniques to build scalable and maintainable frontend applications.</p>"},{"location":"#what-you-will-learn","title":"What You Will Learn","text":"<ul> <li>Setting up a modern frontend project</li> <li>Utilizing feature-based architecture</li> <li>Implementing micro frontends</li> <li>Handling state management</li> <li>Following code guidelines</li> <li>Optimizing performance</li> <li>Testing your application</li> <li>Deploying with CI/CD</li> </ul> <p>Let's get started!</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"micro-frontends/best-approach/","title":"Best Approach","text":"<p>As someone new to Micro Frontends, the best approach for you will depend on your team size, project structure, and deployment preferences. Here's a detailed breakdown of the three strategies and which one is easiest to start with:</p>"},{"location":"micro-frontends/best-approach/#1-monorepo-easiest-to-start","title":"\u2705 1. Monorepo (Easiest to Start)","text":"<p>Monorepo means keeping all your micro frontends in a single repository. This is the easiest approach for small teams or when you're just starting with micro frontends.</p> <p>\u2705 Why Monorepo is Easiest:</p> <ul> <li>Single Codebase: Everything is in one Git repository.</li> <li>Easy to manage shared code: You don\u2019t need a package manager to sync versions across micro frontends.</li> <li>Fast setup: No need for complex CI/CD pipelines for each micro frontend.</li> </ul> \ud83d\ude80 Example Structure<pre><code>modern-frontend/\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 app1/\n\u2502   \u251c\u2500\u2500 app2/\n\u2502   \u2514\u2500\u2500 shared-lib/\n\u2514\u2500\u2500 package.json\n</code></pre> \ud83d\udea7 When to Use <ul> <li>Small projects.</li> <li>Single team managing multiple micro frontends.</li> <li>You need fast collaboration.</li> </ul> <p>Pros:</p> <ul> <li>\u2705 Easy to set up and manage.</li> <li>\u2705 Shared libraries can be updated without publishing separate packages.</li> <li>\u2705 Easier CI/CD pipeline (one pipeline for the whole project).</li> </ul> <p>Cons:</p> <ul> <li>\u274c Doesn\u2019t scale well for large teams or multiple independent deployments.</li> <li>\u274c Slower build times as the repo grows.</li> </ul> \ud83d\udee0 Tools to Use for Monorepo <ul> <li> <p>Nx (recommended for React-based projects):</p> <pre><code>pnpm add -g nx\nnx create-nx-workspace modern-frontend\n</code></pre> </li> <li> <p>Turborepo: Another fast build system for monorepos.</p> </li> </ul>"},{"location":"micro-frontends/best-approach/#2-independent-repos-more-advanced","title":"\ud83d\uddc2\ufe0f 2. Independent Repos (More Advanced)","text":"<p>In this setup, each micro frontend has its own Git repository, its own CI/CD pipeline, and is deployed independently.</p> \ud83d\ude80 Example Structure<pre><code>GitHub/\n\u251c\u2500\u2500 app1/\n\u251c\u2500\u2500 app2/\n\u2514\u2500\u2500 shared-lib/\n</code></pre> \ud83d\udea7 When to Use <ul> <li>Large projects with multiple teams.</li> <li>Each team works on a different micro frontend.</li> <li>You need independent deployment.</li> </ul> <p>Pros:</p> <ul> <li>\u2705 Each micro frontend can be developed, tested, and deployed independently.</li> <li>\u2705 Teams can work in parallel without affecting each other.</li> <li>\u2705 Scales well for large organizations.</li> </ul> <p>Cons:</p> <ul> <li>\u274c Harder to manage shared code (you need to publish shared libraries).</li> <li>\u274c Complex CI/CD pipelines.</li> <li>\u274c Requires more DevOps setup and versioning.</li> </ul>"},{"location":"micro-frontends/best-approach/#3-versioning-and-caching-intermediate","title":"\ud83d\udd04 3. Versioning and Caching (Intermediate)","text":"<p>This is a more advanced approach where you use versioning to manage shared libraries between micro frontends and cache static assets to reduce loading times.</p> <p>\u2705 Why Use Versioning &amp; Caching:</p> <ul> <li>Prevents breaking changes in shared code.</li> <li>Improves performance by caching micro frontend assets.</li> </ul> \ud83d\udea7 When to Use <ul> <li>When your micro frontends are already live and you need backward compatibility.</li> <li>When you want better performance for loading micro frontends.</li> </ul> <p>Pros:</p> <ul> <li>\u2705 Prevents breaking changes with versioned APIs.</li> <li>\u2705 Improved performance with caching mechanisms.</li> </ul> <p>Cons:</p> <ul> <li>\u274c Requires more complex setups (like Webpack Module Federation or Vite).</li> <li>\u274c Harder for beginners to manage version conflicts.</li> </ul>"},{"location":"micro-frontends/best-approach/#recommendation-for-you-monorepo","title":"\ud83c\udfc6 Recommendation for You: Monorepo","text":"<p>Since you're new to Micro Frontends, start with the Monorepo approach because:</p> <ul> <li>It\u2019s easier to set up and manage.</li> <li>You can learn the concepts of micro frontends without worrying about complex deployment pipelines.</li> <li>You can migrate to Independent Repos later as your project grows.</li> </ul>"},{"location":"micro-frontends/best-approach/#steps-to-set-up-monorepo-for-micro-frontends","title":"\ud83d\ude80 Steps to Set Up Monorepo for Micro Frontends:","text":"<p>1\ufe0f\u20e3 Install Nx (Monorepo Tool):</p> <pre><code>pnpm add -g nx\n</code></pre> <p>2\ufe0f\u20e3 Create a Workspace:</p> <pre><code>nx create-nx-workspace modern-frontend\n</code></pre> <p>3\ufe0f\u20e3 Add Micro Frontends (Apps):</p> <pre><code>nx generate @nx/react:app app1\nnx generate @nx/react:app app2\n</code></pre> <p>4\ufe0f\u20e3 Set Up Module Federation for Micro Frontends:</p> <ul> <li>Use Webpack Module Federation to share components and state between micro frontends.</li> </ul>"},{"location":"micro-frontends/best-approach/#key-concepts-to-learn-next","title":"\ud83e\uddd1\u200d\ud83d\udcbb Key Concepts to Learn Next:","text":"<ul> <li>Module Federation (for sharing code between micro frontends).</li> <li>Nx or Turborepo (for managing Monorepos).</li> <li>CI/CD Pipelines for deploying micro frontends.</li> </ul>"},{"location":"micro-frontends/deployment-strategies/","title":"Micro Frontends: Deployment Strategies","text":"<p>Deploying Micro Frontends can be challenging due to their independent nature. Below are some deployment strategies:</p>"},{"location":"micro-frontends/deployment-strategies/#deployment-options","title":"Deployment Options","text":"<ul> <li>Monorepo</li> <li>Independent Repos</li> <li>Versioning and Caching</li> </ul> <pre><code>## Deployment Options\n\n1. **Monorepo**\n   - All Micro Frontends are in a single repository, making it easier to manage dependencies and code sharing.\n\n2. **Independent Repositories**\n   - Each Micro Frontend is in its own repository, allowing for independent versioning and deployment.\n\n3. **Versioning and Caching**\n   - Use semantic versioning and cache-busting strategies to ensure users always get the latest updates.\n</code></pre>"},{"location":"micro-frontends/deployment-strategies/#example-cicd-pipeline","title":"Example CI/CD Pipeline","text":"<pre><code>name: Deploy Micro Frontends\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install dependencies\n        run: pnpm install\n\n      - name: Build application\n        run: pnpm build\n\n      - name: Deploy to S3\n        run: aws s3 sync ./dist s3://my-microfrontend-bucket\n</code></pre>"},{"location":"micro-frontends/detailed-guide/","title":"Detailed Guide","text":"<p>Let's create a detailed guide on setting up a Monorepo with Module Federation for Micro Frontends using Nx. I'll break it down into simple steps, covering:</p> <ul> <li>Project Setup with Nx</li> <li>Creating Micro Frontend Apps</li> <li>Setting Up Module Federation</li> <li>Sharing Components &amp; State</li> <li>Running &amp; Deploying the Micro Frontends</li> </ul> <p>Let me know if you'd like this guide in canvas mode for easy editing, or if you'd prefer me to share it here directly. \ud83d\ude0a</p>"},{"location":"micro-frontends/detailed-guide/#short-guide","title":"Short Guide","text":"<p>Yes, when you create a host app and remote apps using Nx, they are automatically generated inside the <code>apps/</code> folder.</p> Note <p>when we create or generate using <code>npx create-nx-workspace@latest &lt;Workspace name&gt;</code>, then it will gives us list of action to perform. and if we select mono repo with js. it only then create <code>apps/</code> directory or folder. otherwise it doesn't create <code>apps</code> folder.</p> <p>Here's how the file structure looks after running the commands:</p>"},{"location":"micro-frontends/detailed-guide/#folder-structure-after-generating-host-and-remote-apps","title":"\u2705 Folder Structure After Generating Host and Remote Apps","text":"<pre><code>my-mfe-workspace/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 my-host/       \ud83d\udc48 Host App (Main Shell)\n\u2502   \u251c\u2500\u2500 my-remote1/    \ud83d\udc48 Remote App 1\n\u2502   \u2514\u2500\u2500 my-remote2/    \ud83d\udc48 Remote App 2\n\u251c\u2500\u2500 libs/              \ud83d\udc48 (Optional for shared code)\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 nx.json\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 tsconfig.base.json\n</code></pre>"},{"location":"micro-frontends/detailed-guide/#whats-inside-each-app-folder","title":"\ud83d\udcc1 What\u2019s Inside Each App Folder?","text":"Folder Description <code>my-host</code> The host app (main entry point). <code>my-remote1</code> The first remote app. <code>my-remote2</code> The second remote app."},{"location":"micro-frontends/detailed-guide/#how-to-check-the-installed-apps","title":"\u2705 How to Check the Installed Apps","text":"<p>To verify that the apps are installed, run:</p> <pre><code>nx show projects\n</code></pre> You will see an output like this:<pre><code>my-host\nmy-remote1\nmy-remote2\n</code></pre>"},{"location":"micro-frontends/detailed-guide/#ready-to-run-the-apps","title":"\ud83d\ude80 Ready to Run the Apps?","text":"<p>Now that the apps are created, you can serve them by running:</p> <pre><code>nx serve my-host\n</code></pre> <p>This will automatically start:</p> <ul> <li>The host app at <code>http://localhost:4200</code>.</li> <li>The remote apps (<code>my-remote1</code> and <code>my-remote2</code>) on dynamic ports.</li> </ul>"},{"location":"micro-frontends/introduction/","title":"\ud83e\udde9 Micro Frontends: Introduction","text":"<p>Micro Frontends is an architectural style where a frontend application is divided into smaller, independently deployable parts.</p>"},{"location":"micro-frontends/introduction/#benefits","title":"Benefits","text":"<ul> <li>Independent deployments</li> <li>Technology-agnostic</li> <li>Scalable development</li> </ul> <p>Micro Frontends break down large monolithic applications into manageable modules that can be developed, deployed, and maintained separately. This approach enables teams to work on different parts of the application independently, speeding up development and reducing bottlenecks.</p>"},{"location":"micro-frontends/module-federation/","title":"Micro Frontends: Module Federation","text":"<p>Module Federation is a webpack feature that allows sharing code between multiple applications at runtime.</p> <p>Module Federation is a webpack feature that allows sharing code between multiple applications at runtime, making it a key enabler for Micro Frontends.</p>"},{"location":"micro-frontends/module-federation/#why-use-module-federation","title":"Why Use Module Federation?","text":"<ul> <li>Share code dynamically without redeploying the entire application</li> <li>Enable independent deployments</li> <li>Reduce duplication of shared libraries</li> </ul>"},{"location":"micro-frontends/module-federation/#setting-up-module-federation","title":"Setting Up Module Federation","text":"<ol> <li> <p>Install required dependencies:</p> <pre><code>pnpm add webpack module-federation-plugin\n</code></pre> </li> <li> <p>Configure <code>webpack.config.js</code>:</p> <pre><code>const ModuleFederationPlugin =\n  require(\"webpack\").container.ModuleFederationPlugin;\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"app1\",\n      remotes: {\n        app2: \"app2@http://localhost:3002/remoteEntry.js\",\n      },\n      shared: {\n        react: { singleton: true },\n        \"react-dom\": { singleton: true },\n      },\n    }),\n  ],\n};\n</code></pre> </li> </ol>"},{"location":"micro-frontends/module-federation/#example-usage","title":"Example Usage","text":"<p>In your main application (host):</p>"},{"location":"micro-frontends/module-federation/#micro-frontends-shared-state-in-micro-frontends","title":"Micro Frontends: Shared State in Micro Frontends","text":"<p>Sharing state across Micro Frontends can be achieved using libraries like Redux, Zustand, or even custom context solutions.</p>"},{"location":"micro-frontends/module-federation/#approaches-to-shared-state","title":"Approaches to Shared State","text":"<ol> <li> <p>Shared Redux Store:</p> </li> <li> <p>Use a single Redux store shared across applications.</p> </li> <li> <p>Event-Based Communication:</p> </li> <li> <p>Use custom events to communicate between different Micro Frontends.</p> </li> <li> <p>Shared Context Providers:</p> </li> <li>Create a shared context provider that can be consumed by different Micro Frontends.</li> </ol> Example<pre><code>import { createContext, useContext } from \"react\";\n\nconst GlobalStateContext = createContext();\n\nexport function GlobalStateProvider({ children }) {\n  const state = { user: { name: \"John Doe\" } };\n\n  return (\n    &lt;GlobalStateContext.Provider value={state}&gt;\n      {children}\n    &lt;/GlobalStateContext.Provider&gt;\n  );\n}\n\nexport function useGlobalState() {\n  return useContext(GlobalStateContext);\n}\n</code></pre>"},{"location":"micro-frontends/shared-state/","title":"Micro Frontends: Shared State in Micro Frontends","text":"<p>Sharing state across Micro Frontends can be achieved using libraries like Redux or custom state management solutions.</p> <p>Managing shared state across micro frontends is crucial for ensuring consistent user experience and data flow. Sharing state can be tricky because each micro frontend is typically built as an isolated, independent module. Below are strategies and tools to help achieve shared state management in a micro frontend architecture.</p>"},{"location":"micro-frontends/shared-state/#strategies-for-sharing-state","title":"\u2699\ufe0f Strategies for Sharing State","text":""},{"location":"micro-frontends/shared-state/#1-global-event-bus","title":"1. Global Event Bus","text":"<p>A global event bus allows micro frontends to communicate through events. This is a decoupled approach where state is not directly shared, but events trigger actions in different micro frontends.</p> Example<pre><code>// Event Bus Implementation\nconst eventBus = {\n  events: {},\n  subscribe(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  },\n  publish(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach((callback) =&gt; callback(data));\n    }\n  },\n};\n</code></pre> Usage<pre><code>// Micro Frontend 1 (Publisher)\neventBus.publish(\"USER_LOGIN\", { userId: 1 });\n\n// Micro Frontend 2 (Subscriber)\neventBus.subscribe(\"USER_LOGIN\", (data) =&gt; {\n  console.log(\"User logged in:\", data.userId);\n});\n</code></pre>"},{"location":"micro-frontends/shared-state/#2-shared-state-libraries-redux-zustand","title":"2. Shared State Libraries (Redux, Zustand)","text":"<p>A more robust solution is to use a shared state management library, such as Redux or Zustand, across your micro frontends. This can be done by creating a shared package that all micro frontends can import.</p> \ud83d\udd27 Example with Redux <ol> <li> <p>Create a shared package:</p> <pre><code>pnpm add @reduxjs/toolkit react-redux\n</code></pre> </li> <li> <p>Define a shared store:</p> <pre><code>// shared/store.js\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: { isLoggedIn: false, user: null },\n    reducers: {\n        login: (state, action) =&gt; {\n            state.isLoggedIn = true;\n            state.user = action.payload;\n        },\n        logout: state =&gt; {\n            state.isLoggedIn = false;\n            state.user = null;\n        },\n    },\n});\n\nexport const { login, logout } = userSlice.actions;\n\nexport const store = configureStore({\n    reducer: {\n        user: userSlice.reducer,\n    },\n});\n</code></pre> </li> <li> <p>Use the shared store in micro frontends:</p> <pre><code>// Micro Frontend 1\nimport { store, login } from 'shared/store';\nstore.dispatch(login({ name: 'John Doe' }));\n\n// Micro Frontend 2\nimport { useSelector } from 'react-redux';\nconst user = useSelector(state =&gt; state.user);\nconsole.log(user);\n</code></pre> </li> </ol>"},{"location":"micro-frontends/shared-state/#3-module-federation-with-shared-state","title":"3. Module Federation with Shared State","text":"<p>When using Module Federation, you can share state by exposing a central state management module that other micro frontends can consume.</p> \ud83d\udd27 Example<pre><code>// webpack.config.js (Host App)\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"host\",\n      remotes: {\n        mfe1: \"mfe1@http://localhost:3001/remoteEntry.js\",\n      },\n      shared: {\n        react: { singleton: true },\n        \"react-redux\": { singleton: true },\n      },\n    }),\n  ],\n};\n</code></pre>"},{"location":"micro-frontends/shared-state/#tools-for-shared-state","title":"\ud83e\uddf0 Tools for Shared State","text":"<ul> <li>Redux Toolkit: Simplifies shared state management across micro frontends.</li> <li>Zustand: A lightweight alternative to Redux for managing state.</li> <li>Recoil: State management library by Facebook, ideal for micro frontends.</li> <li>RxJS: Enables reactive state sharing across micro frontends through observables.</li> </ul>"},{"location":"micro-frontends/shared-state/#best-practices","title":"\ud83d\udee0 Best Practices","text":"<ol> <li>Avoid tight coupling: Ensure micro frontends remain independent and only rely on shared state when necessary.</li> <li>Use lazy loading: Load shared state only when required to optimize performance.</li> <li>Handle versioning carefully: Ensure all micro frontends use compatible versions of shared libraries.</li> </ol> <p>By implementing one of these strategies, you can efficiently share state across your micro frontends, improving data consistency and the overall user experience.</p>"}]}