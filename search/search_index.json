{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modern Frontend Documentation","text":"<p>Welcome to the Modern Frontend Documentation! This guide covers best practices, project setup, architecture, and development techniques to build scalable and maintainable frontend applications.</p>"},{"location":"#what-you-will-learn","title":"What You Will Learn","text":"<ul> <li>Setting up a modern frontend project</li> <li>Utilizing feature-based architecture</li> <li>Implementing micro frontends</li> <li>Handling state management</li> <li>Following code guidelines</li> <li>Optimizing performance</li> <li>Testing your application</li> <li>Deploying with CI/CD</li> </ul> <p>Let's get started!</p> <p>The biggest problem with shared dependencies is that the parts of the software that use the shared code can diverge in their requirements.</p> <p>When this happens, a developer\u2019s reflex is to cater to different needs while using the same code. That means adding optional parameters, conditional logic to make sure that the shared code can serve two different requirements. This makes the actual code more complicated, eventually causing more problems than it solves. At some point, you start thinking about a more complicated design than copy-pasted code. (1)</p> <ol> <li>page: 66</li> </ol> <p>A street coder is anyone with software development experience in the industry who has had their beliefs and theories shaped by the realities of an unreasonable boss who wanted a week\u2019s worth of work done in the morning.</p> Great street coders <p>In addition to street cred, honor, and loyalty, a street coder ideally possesses these qualities:</p> <ul> <li>Questioning</li> <li>Results-driven (aka, \u201cresults-oriented\u201d in HR-speak)</li> <li>High-throughput</li> <li>Embracing complexity and ambiguity</li> </ul> <p>Great software developers are not just great coders</p> <p>Being a great work colleague involves many more skills than just putting bits and bytes into a computer. You need to be good at communication, provide constructive feedback, and accept criticism like a champion. Even Linus Torvaldsa admitted that he needed to work on his communication skills. However, such skills are outside the scope of this book. You will have to make friends.</p> <p> </p> <p>Enums are great for holding discrete ordinal values. Classes can also be used to define discrete values, but they lack certain affordances that enums have.</p> <ul> <li>Enums are also value types, which means they are as fast as passing around an integer value.</li> </ul>"},{"location":"#reference-book","title":"Reference Book","text":"<ul> <li>Street Coder: THE RULES TO BREAK AND HOW TO BREAK THEM by SEDAT KAPANO\u011eLU</li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"business-logic/backend/","title":"Backend Business Logic","text":"<p>In a web application, business logic refers to the rules and processes that handle the core functionality and operations of the application. It ensures that data is processed, validated, and transformed in a way that supports the goals and workflows of the application. Business logic often involves things like calculations, decision-making, data validation, and any specific actions that reflect the unique needs of a business or organization.</p>"},{"location":"business-logic/backend/#business-logic-in-a-web-application","title":"Business Logic in a Web Application:","text":"<p>Backend (Python): The backend of a web application typically processes requests, manages data, performs authentication and authorization, and ensures that the business rules are enforced. Python is commonly used in the backend (with frameworks like Django, Flask, or FastAPI), where the business logic is written to manipulate and manage data from databases or other sources.</p> <p>Common business logic in the backend may include:</p> <ul> <li>Data validation: Ensuring that the incoming data (such as form submissions or API requests) is in the correct format, free from errors, and meets business requirements.</li> <li>Authorization and Authentication: Deciding who has access to what resources (admin users, regular users, etc.).</li> <li>Database queries and manipulation: Retrieving, updating, or deleting data based on certain criteria and ensuring consistency with business rules.</li> <li>Business-specific operations: For example, applying discount calculations, tax rules, shipping options, etc.</li> <li>File and media handling: Uploading, processing, or validating files such as images, PDFs, etc.</li> </ul> <p>For example, if you're building an e-commerce site in Python, the backend logic might include:</p> <ul> <li>Order calculation: Determine the total price based on quantity, discounts, taxes, shipping costs, etc.</li> <li>Inventory management: Check whether the product is in stock before allowing an order to proceed.</li> </ul>"},{"location":"business-logic/backend/#example-of-business-logic-in-a-python-backend-djangoflask","title":"Example of Business Logic in a Python Backend (Django/Flask):","text":"<ul> <li> <p>Product Pricing Logic:</p> <pre><code>class Product:\n    def __init__(self, price, discount):\n        self.price = price\n        self.discount = discount\n\n    def get_discounted_price(self):\n        return self.price * (1 - self.discount)\n</code></pre> </li> <li> <p>Order Calculation Logic:</p> <pre><code>def calculate_order_total(order_items):\n    total = 0\n    for item in order_items:\n        total += item.product.get_discounted_price() * item.quantity\n    return total\n</code></pre> </li> </ul>"},{"location":"business-logic/backend/#types-of-business-logic-in-backend-python","title":"Types of Business Logic in Backend (Python):","text":"<ul> <li>Data Transformation Logic: Transforming raw data from APIs or databases into a format usable by the application.</li> <li>Authorization Logic: Restricting access to certain resources based on roles or permissions.</li> <li>Calculation Logic: Performing operations like totals, averages, taxes, or other computations.</li> <li>State Management Logic: Managing the state of resources (e.g., pending vs. completed orders).</li> <li>Scheduling or Workflow Logic: Automating tasks like sending notifications, reminders, or updating records at set intervals.</li> </ul>"},{"location":"business-logic/backend/#conclusion","title":"Conclusion:","text":"<ul> <li>Backend (Python): More heavy lifting of business logic, involving data handling, validation, and complex operations.</li> </ul>"},{"location":"business-logic/frontend/","title":"Frontend Business Logic","text":"<p>In the frontend, business logic involves decisions, calculations, and validations that are performed in the user interface (UI) layer. This can range from handling user inputs, dynamically rendering UI components, managing application state, or performing lightweight calculations before submitting data to the backend.</p>"},{"location":"business-logic/frontend/#business-logic-in-a-web-application","title":"Business Logic in a Web Application:","text":"<p>Frontend (React): On the frontend, React focuses more on presenting the user interface (UI) and interacting with the backend. However, some business logic can still reside here, particularly for validating user inputs, managing UI states, and interacting with the backend through APIs.</p> <p>Business logic on the frontend might include:</p> <ul> <li>UI validation: Ensuring that user inputs (like forms) are correct and meet business rules before submitting them to the backend (e.g., checking if a password is strong enough or a form field is not empty).</li> <li>State management: React (with state management tools like Redux or Context API) might handle user session states, application state (such as whether the user is logged in), or dynamically managing the UI based on business rules.</li> <li>Client-side calculations: Some business logic (like calculating a price total or applying a discount) can be handled directly on the client side to improve performance and provide instant feedback to users.</li> </ul> <p>For example, in a React-based frontend for an e-commerce site, the logic might include:</p> <ul> <li>Product search filters: Filtering products based on user-selected criteria (price range, categories, etc.).</li> <li>Cart management: Handling user interactions with the shopping cart, such as adding/removing items and calculating totals.</li> </ul>"},{"location":"business-logic/frontend/#example-of-business-logic-in-a-react-frontend","title":"Example of Business Logic in a React Frontend:","text":"<ul> <li> <p>Cart Calculation:</p> <pre><code>const calculateCartTotal = (cartItems) =&gt; {\n    return cartItems.reduce((total, item) =&gt; {\n    return total + item.price * item.quantity;\n    }, 0);\n};\n</code></pre> </li> <li> <p>Form Validation (Business Rule):</p> <pre><code>const validateEmail = (email) =&gt; {\n    const emailPattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/;\n    return emailPattern.test(email);\n};\n</code></pre> </li> </ul>"},{"location":"business-logic/frontend/#types-of-business-logic-in-frontend-react","title":"Types of Business Logic in Frontend (React):","text":"<ul> <li>State Management: Handling UI state like loading indicators, modal visibility, or form state.</li> <li>Client-Side Validation: Checking inputs before submitting them to the server (e.g., password strength, required fields).</li> <li>Dynamic Rendering: Showing or hiding elements based on business logic (e.g., showing a discount badge only if a product is on sale).</li> <li>Interactive Features: Handling user interactions such as product filtering, search, and sorting.</li> </ul>"},{"location":"business-logic/frontend/#conclusion","title":"Conclusion:","text":"<ul> <li>Frontend (React): Handling user interactions, dynamic updates, and presenting results, but some business logic like validation and minor calculations may also occur here.</li> </ul> <p>Business Logic Definition in Frontend (React)</p> <p>Overview</p> <p>In the frontend, business logic involves decisions, calculations, and validations that are performed in the user interface (UI) layer. This can range from handling user inputs, dynamically rendering UI components, managing application state, or performing lightweight calculations before submitting data to the backend.</p> <p>Key Areas of Business Logic in Frontend React</p> <ol> <li> <p>User Input Validation</p> <p>Validating data entered by users is an essential part of frontend business logic. It ensures that the data is in the correct format or meets certain business rules before being submitted to the backend.</p> <p><code>Example: Validating an Email Address</code></p> <p>In React, a form input validation might check if the email address follows a valid format.</p> <pre><code>import React, { useState } from \"react\";\n\nfunction EmailForm() {\n  const [email, setEmail] = useState(\"\");\n  const [error, setError] = useState(\"\");\n\n  const handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    if (!validateEmail(email)) {\n      setError(\"Invalid email format\");\n    } else {\n      setError(\"\");\n      // Proceed with submitting data to backend\n      console.log(\"Form submitted with:\", email);\n    }\n  };\n\n  const validateEmail = (email) =&gt; {\n    const regex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    return regex.test(email);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input\n        type=\"email\"\n        value={email}\n        onChange={(e) =&gt; setEmail(e.target.value)}\n        placeholder=\"Enter your email\"\n      /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n      {error &amp;&amp; &lt;p style={{ color: \"red\" }}&gt;{error}&lt;/p&gt;}\n    &lt;/form&gt;\n  );\n}\n\nexport default EmailForm;\n</code></pre> <p>In this example, the business logic ensures that the email input is validated before the form is submitted to the backend.</p> </li> <li> <p>State Management</p> <p>React's state management (with hooks like <code>useState</code>, <code>useEffect</code>, or libraries like Redux or Context API) allows you to manage and persist the application state. This logic controls the UI based on user interaction and other factors.</p> <p><code>Example: Managing Cart State</code></p> <p>A shopping cart could have business logic to add and remove items, calculate the total, and apply discounts.</p> <pre><code>import React, { useState } from \"react\";\n\nfunction ShoppingCart() {\n  const [cartItems, setCartItems] = useState([]);\n  const [total, setTotal] = useState(0);\n\n  const addToCart = (item) =&gt; {\n    const updatedCart = [...cartItems, item];\n    setCartItems(updatedCart);\n    calculateTotal(updatedCart);\n  };\n\n  const removeFromCart = (itemId) =&gt; {\n    const updatedCart = cartItems.filter((item) =&gt; item.id !== itemId);\n    setCartItems(updatedCart);\n    calculateTotal(updatedCart);\n  };\n\n  const calculateTotal = (items) =&gt; {\n    const total = items.reduce(\n      (acc, item) =&gt; acc + item.price * item.quantity,\n      0\n    );\n    setTotal(total);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Shopping Cart&lt;/h2&gt;\n      &lt;ul&gt;\n        {cartItems.map((item) =&gt; (\n          &lt;li key={item.id}&gt;\n            {item.name} - ${item.price} x {item.quantity}\n            &lt;button onClick={() =&gt; removeFromCart(item.id)}&gt;Remove&lt;/button&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;p&gt;Total: ${total.toFixed(2)}&lt;/p&gt;\n      &lt;button\n        onClick={() =&gt;\n          addToCart({ id: 1, name: \"Product A\", price: 30, quantity: 1 })\n        }\n      &gt;\n        Add Product A\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default ShoppingCart;\n</code></pre> <p>This example demonstrates the business logic of managing a shopping cart by:</p> <ul> <li>Adding and removing items.</li> <li>Calculating the total price based on the items in the cart.</li> </ul> </li> <li> <p>Conditional Rendering</p> <p>Based on certain conditions, you might display or hide UI elements. This is another example of business logic applied to the frontend.</p> <p><code>Example: Displaying Content Based on User Role</code></p> <p>You can conditionally render content based on the user's role or permissions.</p> <pre><code>import React from \"react\";\n\nfunction UserDashboard({ userRole }) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User Dashboard&lt;/h1&gt;\n      {userRole === \"admin\" &amp;&amp; (\n        &lt;div&gt;\n          &lt;h2&gt;Admin Panel&lt;/h2&gt;\n          &lt;p&gt;Manage users, settings, and more!&lt;/p&gt;\n        &lt;/div&gt;\n      )}\n      {userRole === \"user\" &amp;&amp; (\n        &lt;div&gt;\n          &lt;h2&gt;Welcome User!&lt;/h2&gt;\n          &lt;p&gt;View your profile and activities here.&lt;/p&gt;\n        &lt;/div&gt;\n      )}\n      {userRole !== \"admin\" &amp;&amp; userRole !== \"user\" &amp;&amp; &lt;p&gt;Access denied&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n}\n\nexport default UserDashboard;\n</code></pre> <p>Here, the business logic determines which section of the dashboard to display based on the <code>userRole</code> prop.</p> </li> <li> <p>Client-Side Calculations</p> <p>Simple calculations that need to be done on the client-side (without needing to hit the backend) are often part of the business logic. This could involve calculating discounts, applying tax, or any other logic required before finalizing a transaction.</p> <p><code>Example: Calculating Discount Before Checkout</code></p> <p>In a checkout process, you might need to apply a discount based on certain conditions, such as coupon codes or sales.</p> <pre><code>import React, { useState } from \"react\";\n\nfunction Checkout() {\n  const [total, setTotal] = useState(100); // Initial total\n  const [discount, setDiscount] = useState(0);\n  const [finalPrice, setFinalPrice] = useState(total);\n\n  const applyDiscount = (code) =&gt; {\n    let discountAmount = 0;\n\n    if (code === \"SAVE10\") {\n      discountAmount = total * 0.1; // 10% discount\n    } else if (code === \"FREESHIP\") {\n      discountAmount = 20; // Flat $20 discount\n    }\n\n    setDiscount(discountAmount);\n    setFinalPrice(total - discountAmount);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Checkout&lt;/h2&gt;\n      &lt;p&gt;Total: ${total}&lt;/p&gt;\n      &lt;p&gt;Discount: ${discount}&lt;/p&gt;\n      &lt;p&gt;Final Price: ${finalPrice.toFixed(2)}&lt;/p&gt;\n      &lt;input\n        type=\"text\"\n        placeholder=\"Enter discount code\"\n        onChange={(e) =&gt; applyDiscount(e.target.value)}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Checkout;\n</code></pre> <p>In this example, the business logic applies a discount based on the user's input, modifying the total price of the checkout.</p> </li> </ol> <p>Conclusion</p> <p>Business logic in the frontend (React) involves a variety of tasks, including input validation, managing state, applying calculations, handling conditional rendering, and controlling the flow of the UI based on the user\u2019s interactions and business rules. This ensures that the user experience is smooth, data is consistent, and the application behaves according to the business requirements.</p>"},{"location":"business-logic/overview/","title":"Business Logic in Web Applications:","text":"<p>Business logic refers to the rules and operations that define how the application behaves, processes data, and responds to certain actions. While the core business logic of an application usually resides in the backend, there can be some frontend business logic as well. However, frontend logic is typically lightweight and focused on the user interface and immediate user interactions, while backend logic deals with the more complex and sensitive operations.</p>"},{"location":"business-logic/overview/#1-business-logic-in-the-backend-net-core","title":"1. Business Logic in the Backend (.NET Core)","text":"<p>The backend handles heavy business logic because it deals with more sensitive operations, data processing, validation, security, and interactions with the database or third-party services. This is where the core rules and data operations happen. Here are some examples:</p> <ul> <li> <p>Data Validation and Integrity: Ensuring that the data provided by the user (through frontend) is valid, consistent, and accurate before processing it or storing it in a database.</p> <ul> <li>E.g., checking if a user\u2019s email is in the correct format, verifying passwords, ensuring data consistency.</li> </ul> </li> <li> <p>Authentication &amp; Authorization: Verifying user identity (login) and ensuring they have permission to access certain resources or perform certain actions.</p> <ul> <li>E.g., checking if a user can access an admin panel or if they are allowed to view certain data.</li> </ul> </li> <li> <p>Complex Business Rules: Rules that involve data processing, calculations, or transformation that can\u2019t be done on the frontend. This includes pricing calculations, tax applications, or processing complex workflows.</p> <ul> <li>E.g., calculating the total price with discounts, tax, and shipping.</li> </ul> </li> <li> <p>Database Operations: Handling CRUD operations (Create, Read, Update, Delete) in a secure way with business rules applied. This is where data is actually stored and retrieved based on business logic.</p> <ul> <li>E.g., updating a user\u2019s profile, creating an order, or adjusting inventory based on sales.</li> </ul> </li> <li> <p>Integrations: Communicating with external services like payment gateways (e.g., Stripe, PayPal), email services (e.g., SendGrid), or external APIs.</p> <ul> <li>E.g., processing a payment, sending an email confirmation, or checking the weather.</li> </ul> </li> </ul>"},{"location":"business-logic/overview/#2-business-logic-in-the-frontend-react","title":"2. Business Logic in the Frontend (React)","text":"<p>The frontend (React, in your case) does include business logic, but this logic is usually focused on user interaction, UI behavior, and basic data validation. It handles the parts of the application that deal directly with what the user sees and interacts with. Some examples of business logic in the frontend include:</p> <ol> <li> <p>Client-Side Validation: Performing basic validation checks on form inputs before sending them to the backend. This improves the user experience by providing immediate feedback.</p> <ul> <li>E.g., checking if the email input field contains a valid email address, ensuring required fields are filled, or validating password length.</li> </ul> </li> <li> <p>Dynamic User Interface Logic: Logic that controls the display or interaction of UI components based on the user's input or other dynamic factors.</p> <ul> <li>E.g., toggling visibility of certain elements, updating the view based on user selections, or handling pagination for a list of items.</li> </ul> </li> <li> <p>State Management: Managing the state of the application (e.g., using React state or libraries like Redux) to control what the user sees and interacts with based on the application\u2019s current state.</p> <ul> <li>E.g., updating the shopping cart in real-time as the user adds or removes items.</li> </ul> </li> <li> <p>Sorting or Filtering Data: Sometimes, frontend applications may need to sort or filter data based on user actions without needing to contact the backend.</p> <ul> <li>E.g., sorting a list of products by price or category, filtering search results based on user criteria.</li> </ul> </li> </ol>"},{"location":"business-logic/overview/#key-differences","title":"Key Differences:","text":"<ol> <li> <p>Security:</p> <ul> <li>Backend: The backend is where you should keep any sensitive or critical business logic (e.g., authentication, payment processing, etc.) because it is more secure and can be controlled. Frontend code (React) can be seen and modified by the user, so business logic related to security should not be there.</li> </ul> </li> <li> <p>Complexity:</p> <ul> <li>Backend: The backend should handle complex logic like data processing, working with databases, and enforcing core business rules. This is because backend services can be more powerful, manage large amounts of data securely, and can perform computations without exposing sensitive logic to the user.</li> </ul> </li> <li> <p>User Experience:</p> <ul> <li>Frontend: The frontend can handle simple, non-sensitive logic such as UI behavior and client-side validations. These operations enhance the user experience and can help prevent unnecessary backend calls by providing immediate feedback or adjusting the UI without needing a round-trip to the server.</li> </ul> </li> </ol>"},{"location":"business-logic/overview/#when-react-frontend-uses-business-logic","title":"When React (Frontend) Uses Business Logic:","text":"<ul> <li> <p>Business logic related to user interaction: For example, showing a confirmation message after a successful form submission, managing the state of UI components (e.g., whether a menu is open or closed), or dynamically updating data displayed to the user based on input.</p> </li> <li> <p>Lightweight validation: For instance, checking if the user\u2019s email is in the correct format, verifying if a field is not empty, etc. However, you still need to validate the data on the backend to ensure data integrity.</p> </li> </ul>"},{"location":"business-logic/overview/#when-net-core-backend-uses-business-logic","title":"When .NET Core (Backend) Uses Business Logic:","text":"<ul> <li>Complex business rules and processing: Calculating prices with discounts, interacting with databases, processing payments, or handling workflows that span multiple steps or resources.</li> <li>Data consistency and validation: Ensuring that data sent by the frontend is valid, correctly formatted, and safe to process before saving to the database.</li> </ul>"},{"location":"business-logic/overview/#summary","title":"Summary:","text":"<ul> <li>Frontend (React): Handles UI-related logic, lightweight validation, and things like state management and user interaction. This includes non-sensitive business logic.</li> <li>Backend (.NET Core): Handles core business logic, complex data processing, security, and database interactions. The backend is where the critical business rules should live, especially for things like user authentication, payment processing, and data manipulation.</li> </ul> <p>In short, business logic does exist in both frontend and backend, but the backend is where you store the core logic that is critical, secure, and complex, while the frontend focuses on making the user experience more interactive and responsive.</p>"},{"location":"challenges/dynamic-favicon/","title":"Dynamic Favicon","text":"<pre><code>document.querySelector(\"link[rel~='icon']\")\n</code></pre>"},{"location":"challenges/dynamic-favicon/#strategy-best-for-notes","title":"Strategy Best For Notes","text":"<ol> <li>Hostname/Subdomain One app deployed for all clients Dynamic, one build</li> <li>Env Variable per Build Separate builds per client Static favicon per client build</li> <li>API-based User-based or late client detection Set favicon after API response</li> </ol> Strategy Best For Notes Hostname/Subdomain One app deployed for all clients Dynamic, one build Env Variable per Build Separate builds per client Static favicon per client build API-based User-based or late client detection User-based or late client detection"},{"location":"challenges/dynamic-favicon/#env-variable-method","title":"Env Variable METHOD","text":"config.js<pre><code>export const DOMAIN_LISTS = {\n  INFOCOM: \"info\",\n  PRABHU: \"bank\",\n  NIMB: \"nimb\",\n  ADBL: \"adbl\",\n};\n\nexport const PATH = {\n  ASSETS: \"/assets/\",\n};\n\nexport const FAVICONS = {\n  [DOMAIN_LISTS.INFOCOM]: `${PATH.ASSETS}infocom.ico`,\n  [DOMAIN_LISTS.PRABHU]: `${PATH.ASSETS}prabhu.ico`,\n  [DOMAIN_LISTS.NIMB]: `${PATH.ASSETS}nimb.ico`,\n  [DOMAIN_LISTS.ADBL]: `${PATH.ASSETS}adbl.ico`,\n};\n</code></pre> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;!-- REMOVE THIS FROM HERE  --&gt;\n    &lt;!-- &lt;link rel=\"icon\" type=\"image/svg+xml\" href=\"/assets/favicon.ico\" /&gt; --&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Bank App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"root\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"/src/main.jsx\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> App.jsx<pre><code>import { DOMAIN_LISTS, FAVICONS, PATH } from \"@shared/utils/config\"; // Adjust the import path as needed\nconst buildMode = import.meta.env.VITE_REACT_APP_BUILD_MODE; // e.g. \"adbl\", \"info\", etc.\n\nimport { useEffect } from \"react\";\nimport { DOMAIN_LISTS, FAVICONS, PATH } from \"@shared/utils/config\";\n\nfunction App() {\n  const buildMode = import.meta.env.VITE_REACT_APP_BUILD_MODE;\n\n  useEffect(() =&gt; {\n    let favicon = document.querySelector(\"link[rel~='icon']\");\n    if (!favicon) {\n      favicon = document.createElement(\"link\");\n      favicon.rel = \"icon\";\n      favicon.type = \"image/x-icon\";\n      document.head.appendChild(favicon);\n    }\n\n    // Set favicon based on buildMode, fallback to default.ico if not found\n    favicon.href = FAVICONS[buildMode] || `${PATH.ASSETS}default.ico`;\n  }, [buildMode]);\n\n  return (\n    // Your component JSX here\n  );\n}\n\nexport default App;\n</code></pre> What this does: <p>On component mount or whenever <code>buildMode</code> changes, it:</p> <ul> <li>Looks for existing <code>&lt;link rel=\"icon\"&gt;</code> tag or creates one.</li> <li>Sets its <code>href</code> to the correct favicon path from your <code>FAVICONS</code> map.</li> <li>Falls back to <code>/assets/default.ico</code> if <code>buildMode</code> is not mapped.</li> </ul> <p>Bonus tips:</p> <ul> <li>Make sure <code>default.ico</code> exists at <code>/assets/default.ico</code>.</li> <li>Ensure your favicon files exist at the correct locations.</li> <li>Clear browser cache or test in incognito to see changes immediately.</li> </ul>"},{"location":"challenges/dynamic-favicon/#add-a-small-cache-busting-query-param-to-avoid-favicon-being-stuck-in-browser-cache-optional","title":"Add a small cache-busting query param to avoid favicon being stuck in browser cache (optional):","text":"<pre><code>favicon.href = `${\n  FAVICONS[CONFIG.BUILD_MODE] || `${PATH.ASSETS}default.ico`\n}?v=${Date.now()}`;\n</code></pre> <p>Only necessary during dev or frequent icon switching, though.</p>"},{"location":"challenges/dynamic-favicon/#include-a-fallback-link-relicon-in-indexhtml-for-early-loading","title":"Include a fallback <code>&lt;link rel=\"icon\" /&gt;</code> in <code>index.html</code> for early loading","text":"<p>This prevents the browser from defaulting to <code>/favicon.ico</code> before your React app mounts.</p> <p>In <code>public/index.html</code> (or whatever your entry HTML is):</p> <pre><code>&lt;link rel=\"icon\" href=\"/assets/default.ico\" type=\"image/x-icon\" /&gt;\n</code></pre> <p>Then your dynamic logic will override this as soon as React loads.</p> <p>EXTRA</p> <p>If i add the the <code>favicon.ico</code> in the <code>index.html</code></p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;!-- THIS  --&gt;\n    &lt;link rel=\"icon\" type=\"image/svg+xml\" href=\"/assets/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Bank App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"root\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"/src/main.jsx\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>useEffect(() =&gt; {\n  // Remove any existing favicon tags\n  const existingIcons = document.querySelectorAll(\"link[rel*='icon']\");\n  existingIcons.forEach((el) =&gt; el.parentNode.removeChild(el));\n\n  const favicon = document.createElement(\"link\");\n  favicon.rel = \"icon\";\n  favicon.type = \"image/x-icon\";\n  favicon.href = `${\n    FAVICONS[CONFIG.BUILD_MODE] || `${PATH.ASSETS}default.ico`\n  }?v=${Date.now()}`;\n  document.head.appendChild(favicon);\n}, [CONFIG.BUILD_MODE]);\n</code></pre>"},{"location":"challenges/dynamic-favicon/#antd","title":"Antd","text":"<pre><code>import React from \"react\";\nimport { Image } from \"antd\";\nconst App = () =&gt; (\n  &lt;Image\n    width={200}\n    height={200}\n    src=\"error\"\n    fallback=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==\"\n  /&gt;\n);\nexport default App;\n</code></pre>"},{"location":"challenges/dynamic-favicon/#reference","title":"Reference","text":"<ul> <li>Configure Fallback Images in React and Next.js </li> <li>React Fallback for Broken Images Strategy</li> <li>Antd Image</li> </ul>"},{"location":"challenges/multiple-id-status-tracker-polling/","title":"Multi-ID Status Tracker with RTK polling","text":"\u274c The issue is this line: <pre><code>const res = await trigger(id, true).unwrap();\n</code></pre> <p>This is incorrect usage of RTK Query's lazy query <code>trigger</code> function. You are passing a raw <code>id</code> instead of the expected object \u2014 and <code>true</code> as a second argument which isn't needed here.</p> \u2705 Fix it like this: <p>In <code>useStatusPoller.js</code>, update this line:</p> <pre><code>- const res = await trigger(id, true).unwrap();\n+ const res = await trigger({ id }).unwrap();\n</code></pre> useStatusPoller.jsMultiStatusPoller.jsxStatusDisplay.jsx <pre><code>import { useState, useEffect } from \"react\";\nimport { useLazyGetStatusQuery } from \"../services/chunkApi\";\n\nconst terminalStatuses = [\"completed\", \"failed\"];\n\nexport default function useStatusPoller(id, enabled = true) {\n    const [trigger] = useLazyGetStatusQuery();\n    const [status, setStatus] = useState(\"pending\");\n    const [progress, setProgress] = useState(0);\n\n    useEffect(() =&gt; {\n        if (!enabled || !id) return;\n\n        let stopped = false;\n\n        async function poll() {\n\n            if (stopped) return;\n\n            try {\n                const res = await trigger({ id }).unwrap(); // \u2705 FIXED\n\n                if (res) {\n                    setStatus(res.status);\n                    setProgress(res.progress);\n\n                    if (!terminalStatuses.includes(res.status)) {\n                        setTimeout(poll, 5000);\n                    }\n                }\n            } catch (error) {\n                console.error(`Error polling for ${id}:`, error);\n                setTimeout(poll, 10000);\n            }\n        }\n\n        poll();\n\n        return () =&gt; {\n            stopped = true;\n        };\n    }, [id, enabled, trigger]);\n\n    return { status, progress };\n}\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport StatusDisplay from \"./StatusDisplay\";\nimport { useGetStatusListingQuery } from \"../services/chunkApi\";\n\nexport default function MultiStatusPoller() {\n    const { data: statusListing } = useGetStatusListingQuery();\n\n    return (\n        &lt;div&gt;\n            {statusListing?.map((item) =&gt; (\n                &lt;StatusDisplay key={item?.id} id={item?.id} /&gt;\n            ))}\n        &lt;/div&gt;\n    );\n}\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport useStatusPoller from \"./useStatusPoller\";\n\nexport default function StatusDisplay({ id }) {\n    const [started, setStarted] = useState(false);\n    const { status, progress } = useStatusPoller(id, started);\n\n    const handleStart = () =&gt; {\n        setStarted(true);\n    };\n\n    return (\n        &lt;div\n            style={{\n                marginBottom: \"1rem\",\n                border: \"1px solid #ddd\",\n                padding: \"10px\",\n                borderRadius: \"6px\",\n            }}\n        &gt;\n        {!started ? (\n            &lt;button onClick={handleStart}&gt;Start&lt;/button&gt;\n        ) : (\n            &lt;&gt;\n                &lt;h4&gt;ID: {id}&lt;/h4&gt;\n                &lt;p&gt;\n                    Status: &lt;strong&gt;{status}&lt;/strong&gt;\n                &lt;/p&gt;\n                &lt;progress value={progress} max=\"100\" style={{ width: \"100%\" }} /&gt;\n                &lt;p&gt;{progress}%&lt;/p&gt;\n            &lt;/&gt;\n        )}\n        &lt;/div&gt;\n    );\n}\n</code></pre>"},{"location":"challenges/multiple-id-status-tracker-polling/#also-confirm-your-chunkapi-definition","title":"\u2705 Also, confirm your chunkApi definition:","text":"<p>Make sure your API slice has this:</p> <pre><code>getStatus: builder.query({\n  query: ({ id }) =&gt; ({\n    url: `api/status/${id}`,\n    method: \"GET\",\n  }),\n}),\n</code></pre> <p>And you're exporting it:</p> <pre><code>export const {\n  useLazyGetStatusQuery,\n  useGetStatusListingQuery,\n  // other hooks...\n} = chunkApi;\n</code></pre>"},{"location":"challenges/multiple-id-status-tracker-polling/#test-and-verify","title":"\u2705 Test and verify:","text":"<ul> <li>When you click \"Start\" for an ID, it should now call <code>trigger({ id })</code>, get the status, and keep polling until <code>completed</code> or <code>failed</code>.</li> </ul> <p>Let me know if you also want to:</p> <ul> <li>Add a Stop button,</li> <li>Show loading/error states,</li> <li>Or batch trigger polling for multiple IDs.</li> </ul> <pre><code>  - Home: index.md\n  - Setup: setup.md\n  - Components: components.md\n  - API Mocking: mocking.md\n  - Polling Logic: polling.md\n</code></pre>"},{"location":"challenges/multiple-id-status-tracker-polling/#updated-features","title":"Updated Features","text":""},{"location":"challenges/multiple-id-status-tracker-polling/#start-and-stop","title":"Start and Stop","text":"<pre><code>import React, { useState } from \"react\";\nimport useStatusPoller from \"./useStatusPoller\";\n\nexport default function StatusDisplay({ id }) {\n  const [started, setStarted] = useState(false);\n  const { status, progress, loading, error, stop } = useStatusPoller(\n    id,\n    started\n  );\n\n  const handleStart = () =&gt; {\n    setStarted(true);\n  };\n\n  const handleStop = () =&gt; {\n    stop();\n    setStarted(false);\n  };\n\n  return (\n    &lt;div\n      style={{\n        marginBottom: \"1rem\",\n        border: \"1px solid #ddd\",\n        padding: \"10px\",\n        borderRadius: \"6px\",\n        backgroundColor: \"#f9f9f9\",\n      }}\n    &gt;\n      &lt;h4&gt;ID: {id}&lt;/h4&gt;\n\n      {!started ? (\n        &lt;button onClick={handleStart}&gt;Start&lt;/button&gt;\n      ) : (\n        &lt;&gt;\n          &lt;button onClick={handleStop} style={{ marginBottom: \"10px\" }}&gt;\n            Stop\n          &lt;/button&gt;\n          &lt;p&gt;\n            Status: &lt;strong&gt;{status}&lt;/strong&gt;\n          &lt;/p&gt;\n          &lt;progress value={progress} max=\"100\" style={{ width: \"100%\" }} /&gt;\n          &lt;p&gt;{progress}%&lt;/p&gt;\n\n          {loading &amp;&amp; &lt;p style={{ color: \"blue\" }}&gt;Polling...&lt;/p&gt;}\n          {error &amp;&amp; &lt;p style={{ color: \"red\" }}&gt;{error}&lt;/p&gt;}\n        &lt;/&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre> \u2705 Result: <ul> <li>Start and Stop buttons to control polling</li> <li>Shows \"Polling...\" while loading</li> <li>Shows error messages if polling fails</li> <li> <p>Stops polling when:</p> <ul> <li>You click \"Stop\"</li> <li>The status reaches <code>completed</code> or <code>failed</code></li> </ul> </li> </ul>"},{"location":"challenges/multiple-id-status-tracker-polling/#global-startstop-all","title":"Global: Start/Stop All","text":"<ul> <li>Automatically restart polling after failure</li> <li>Add global polling controls (start all / stop all)</li> <li>Make a timeline or animation to show progress visually</li> </ul> full working setup that includes <ul> <li>\u2705 Start/Stop polling per ID</li> <li>\u2705 Loading and error states</li> <li>\u2705 Optional: \"Start All\" / \"Stop All\" button (at bottom)</li> </ul> 1. useStatusPoller.js2. StatusDisplay.jsx3. MultiStatusPoller.jsx <p>\ud83d\udd27 1. <code>useStatusPoller.js</code> (with polling + stop + error/loading)</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { useLazyGetStatusQuery } from \"../services/chunkApi\";\n\nconst terminalStatuses = [\"completed\", \"failed\"];\n\nexport default function useStatusPoller(id, enabled = true) {\n    const [trigger] = useLazyGetStatusQuery();\n    const [status, setStatus] = useState(\"idle\");\n    const [progress, setProgress] = useState(0);\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const stopRef = useRef(false);\n\n    useEffect(() =&gt; {\n        if (!enabled || !id) return;\n\n        stopRef.current = false;\n\n        async function poll() {\n            if (stopRef.current) return;\n\n            try {\n                setLoading(true);\n                setError(null);\n                const res = await trigger({ id }).unwrap();\n                setLoading(false);\n\n                if (res) {\n                    setStatus(res.status);\n                    setProgress(res.progress);\n\n                    if (!terminalStatuses.includes(res.status)) {\n                        setTimeout(poll, 5000);\n                    }\n                }\n            } catch (err) {\n                setLoading(false);\n                setError(\"Failed to fetch status. Retrying...\");\n                console.error(`Polling error for ${id}:`, err);\n                setTimeout(poll, 10000);\n            }\n        }\n\n        poll();\n\n        return () =&gt; {\n            stopRef.current = true;\n        };\n    }, [id, enabled, trigger]);\n\nconst stop = () =&gt; {\n    stopRef.current = true;\n};\n\nreturn { status, progress, loading, error, stop };\n}\n</code></pre> <p>\ud83c\udf9b\ufe0f 2. StatusDisplay.jsx (with Start/Stop buttons + UI)</p> <pre><code>import React, { useState } from \"react\";\nimport useStatusPoller from \"./useStatusPoller\";\n\nexport default function StatusDisplay({\n    id,\n    globalStart = false,\n    globalStop = false,\n}) {\n    const [started, setStarted] = useState(false);\n    const { status, progress, loading, error, stop } = useStatusPoller(\n        id,\n        started || globalStart\n    );\n\n    // If globalStop is triggered, stop local polling\n    React.useEffect(() =&gt; {\n        if (globalStop) {\n            stop();\n            setStarted(false);\n        }\n    }, [globalStop]);\n\n    const handleStart = () =&gt; {\n        setStarted(true);\n    };\n\n    const handleStop = () =&gt; {\n        stop();\n        setStarted(false);\n    };\n\n    return (\n        &lt;div\n            style={{\n                marginBottom: \"1rem\",\n                border: \"1px solid #ddd\",\n                padding: \"10px\",\n                borderRadius: \"6px\",\n                backgroundColor: \"#f9f9f9\",\n            }}\n        &gt;\n        &lt;h4&gt;ID: {id}&lt;/h4&gt;\n\n        {!started &amp;&amp; !globalStart ? (\n            &lt;button onClick={handleStart}&gt;Start&lt;/button&gt;\n        ) : (\n            &lt;&gt;\n                &lt;button onClick={handleStop} style={{ marginBottom: \"10px\" }}&gt;\n                    Stop\n                &lt;/button&gt;\n                &lt;p&gt;\n                    Status: &lt;strong&gt;{status}&lt;/strong&gt;\n                &lt;/p&gt;\n                &lt;progress value={progress} max=\"100\" style={{ width: \"100%\" }} /&gt;\n                &lt;p&gt;{progress}%&lt;/p&gt;\n                {loading &amp;&amp; &lt;p style={{ color: \"blue\" }}&gt;Polling...&lt;/p&gt;}\n                {error &amp;&amp; &lt;p style={{ color: \"red\" }}&gt;{error}&lt;/p&gt;}\n            &lt;/&gt;\n        )}\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>\ud83e\udde9 <code>3. MultiStatusPoller.jsx</code> (global start/stop all)</p> <pre><code>import React, { useState } from \"react\";\nimport StatusDisplay from \"./StatusDisplay\";\nimport { useGetStatusListingQuery } from \"../services/chunkApi\";\n\nexport default function MultiStatusPoller() {\n    const { data: statusListing = [] } = useGetStatusListingQuery();\n    const [globalStart, setGlobalStart] = useState(false);\n    const [globalStop, setGlobalStop] = useState(false);\n\n    const handleStartAll = () =&gt; {\n        setGlobalStart(true);\n        setGlobalStop(false);\n    };\n\n    const handleStopAll = () =&gt; {\n        setGlobalStop(true);\n        setGlobalStart(false);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;div style={{ marginBottom: \"20px\" }}&gt;\n                &lt;button onClick={handleStartAll} style={{ marginRight: \"10px\" }}&gt;\n                Start All\n                &lt;/button&gt;\n                &lt;button onClick={handleStopAll}&gt;Stop All&lt;/button&gt;\n            &lt;/div&gt;\n\n            {statusListing.map((item) =&gt; (\n                &lt;StatusDisplay\n                key={item.id}\n                id={item.id}\n                globalStart={globalStart}\n                globalStop={globalStop}\n                /&gt;\n            ))}\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>\u2705 What This Now Does</p> Feature \u2705 Supported Start individual polling \u2705 Stop individual polling \u2705 Start all polling \u2705 Stop all polling \u2705 Show loading/error state \u2705 Stops polling on terminal status \u2705 <p>Let me know if you'd like to:</p> <ul> <li>Add auto-restart on error</li> <li>Track polling logs</li> <li>Show timestamps or polling history</li> </ul>"},{"location":"challenges/multiple-id-status-tracker-polling/#updated-3","title":"Updated 3","text":"<ul> <li>Add auto-restart on error</li> <li>Track polling logs</li> <li>Show timestamps or polling history</li> </ul> 1. useStatusPoller.js2. StatusDisplay.jsx3. MultiStatusPoller.jsx <p>\ud83e\udde9 1. <code>useStatusPoller.js</code> (polling with Start/Stop, loading &amp; error)</p> <pre><code>import { useState, useEffect, useRef } from \"react\";\nimport { useLazyGetStatusQuery } from \"../services/chunkApi\";\n\nconst terminalStatuses = [\"completed\", \"failed\"];\n\nexport default function useStatusPoller(id, enabled = false) {\n    const [trigger] = useLazyGetStatusQuery();\n    const [status, setStatus] = useState(\"idle\");\n    const [progress, setProgress] = useState(0);\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const stopRef = useRef(false);\n\n    useEffect(() =&gt; {\n        if (!enabled || !id) return;\n\n        stopRef.current = false;\n\n        async function poll() {\n            if (stopRef.current) return;\n\n            try {\n                setLoading(true);\n                setError(null);\n                const res = await trigger({ id }).unwrap();\n                setLoading(false);\n\n                setStatus(res.status);\n                setProgress(res.progress);\n\n                if (!terminalStatuses.includes(res.status)) {\n                    // continue polling\n                    setTimeout(poll, 5000);\n                }\n            } catch (err) {\n                setLoading(false);\n                setError(\"Polling error \u2013 retrying\u2026\");\n                // retry after delay\n                setTimeout(poll, 10000);\n            }\n        }\n\n        poll();\n\n        return () =&gt; {\n            stopRef.current = true;\n        };\n\n    }, [id, enabled, trigger]);\n\n    const stop = () =&gt; { stopRef.current = true; };\n\n    return { status, progress, loading, error, stop };\n}\n</code></pre> <p>\ud83d\uddbc\ufe0f 2. <code>StatusDisplay.jsx</code> (Start/Stop UI with feedback)</p> <pre><code>import React, { useState, useEffect } from \"react\";\nimport useStatusPoller from \"./useStatusPoller\";\n\nexport default function StatusDisplay({ id, globalStart = false, globalStop = false }) {\n    const [started, setStarted] = useState(false);\n    const enabled = started || globalStart;\n    const { status, progress, loading, error, stop } = useStatusPoller(id, enabled);\n\n    useEffect(() =&gt; {\n        if (globalStop) {\n            stop();\n            setStarted(false);\n        }\n    }, [globalStop]);\n\n    const handleStart = () =&gt; setStarted(true);\n    const handleStop = () =&gt; { stop(); setStarted(false); };\n\n    return (\n        &lt;div style={styles.card}&gt;\n            &lt;h4&gt;ID: {id}&lt;/h4&gt;\n            {!enabled ? (\n                &lt;button onClick={handleStart}&gt;Start&lt;/button&gt;\n            ) : (\n                &lt;&gt;\n                    &lt;button onClick={handleStop} style={styles.stopButton}&gt;Stop&lt;/button&gt;\n                    &lt;p&gt;Status: &lt;strong&gt;{status}&lt;/strong&gt;&lt;/p&gt;\n                    &lt;progress value={progress} max=\"100\" style={styles.progressBar} /&gt;\n                    &lt;p&gt;{progress}%&lt;/p&gt;\n                    {loading &amp;&amp; &lt;p style={styles.info}&gt;Polling\u2026&lt;/p&gt;}\n                    {error &amp;&amp; &lt;p style={styles.error}&gt;{error}&lt;/p&gt;}\n                &lt;/&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nconst styles = {\n    card: {\n        border: \"1px solid #ddd\",\n        padding: \"10px\",\n        borderRadius: \"6px\",\n        marginBottom: \"1rem\",\n        backgroundColor: \"#f9f9f9\",\n    },\n    stopButton: {\n        marginBottom: \"10px\",\n    },\n    progressBar: {\n        width: \"100%\",\n    },\n    info: {\n        color: \"blue\",\n    },\n    error: {\n        color: \"red\",\n    },\n};\n</code></pre> <p>\ud83e\uddf0 3. <code>MultiStatusPoller.jsx</code> (global Start All / Stop All + dynamic IDs)</p> <pre><code>import React, { useState } from \"react\";\nimport StatusDisplay from \"./StatusDisplay\";\nimport { useGetStatusListingQuery } from \"../services/chunkApi\";\n\nexport default function MultiStatusPoller() {\n    const { data: statusListing = [] } = useGetStatusListingQuery();\n    const [globalStart, setGlobalStart] = useState(false);\n    const [globalStop, setGlobalStop] = useState(false);\n\n    const handleStartAll = () =&gt; {\n        setGlobalStart(true);\n        setGlobalStop(false);\n    };\n    const handleStopAll = () =&gt; {\n        setGlobalStop(true);\n        setGlobalStart(false);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;div style={{ marginBottom: \"20px\" }}&gt;\n                &lt;button onClick={handleStartAll} style={{ marginRight: \"10px\" }}&gt;Start All&lt;/button&gt;\n                &lt;button onClick={handleStopAll}&gt;Stop All&lt;/button&gt;\n            &lt;/div&gt;\n\n            {statusListing.map(item =&gt; (\n                &lt;StatusDisplay\n                key={item.id}\n                id={item.id}\n                globalStart={globalStart}\n                globalStop={globalStop}\n                /&gt;\n            ))}\n        &lt;/div&gt;\n    );\n}\n</code></pre> src/services/chunkApi.js<pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const chunkApi = createApi({\n  reducerPath: \"chunkApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"https://example.com/\" }),\n  endpoints: (builder) =&gt; ({\n    getStatusListing: builder.query({\n      query: () =&gt; \"api/statusListing\",\n    }),\n    getStatus: builder.query({\n      query: ({ id }) =&gt; ({\n        url: `api/status/${id}`,\n        method: \"GET\",\n      }),\n    }),\n  }),\n});\n\nexport const { useGetStatusListingQuery, useLazyGetStatusQuery } = chunkApi;\n</code></pre> src/mocks/handlers.js<pre><code>import { rest } from \"msw\";\nimport { faker } from \"@faker-js/faker\";\n\nconst statuses = [\"pending\", \"processing\", \"completed\", \"failed\"];\n\nexport const handlers = [\n  rest.get(\"https://example.com/api/statusListing\", (req, res, ctx) =&gt; {\n    return res(ctx.json([{ id: \"id1\" }, { id: \"id2\" }, { id: \"id3\" }]));\n  }),\n  rest.get(\"https://example.com/api/status/:id\", (req, res, ctx) =&gt; {\n    const id = req.params.id;\n    const chance = Math.random();\n    const status =\n      chance &lt; 0.6\n        ? \"processing\"\n        : chance &lt; 0.85\n        ? \"pending\"\n        : chance &lt; 0.95\n        ? \"completed\"\n        : \"failed\";\n    const progress =\n      status === \"completed\"\n        ? 100\n        : status === \"failed\"\n        ? 0\n        : faker.datatype.number({ min: 0, max: 99 });\n    return res(ctx.status(200), ctx.json({ id, status, progress }));\n  }),\n];\n</code></pre> src/mocks/browser.js<pre><code>import { setupWorker } from \"msw\";\nimport { handlers } from \"./handlers\";\nexport const worker = setupWorker(...handlers);\n</code></pre>"},{"location":"challenges/multiple-id-status-tracker-polling/#reference","title":"Reference","text":"<ul> <li>RTK Official: Polling Overview</li> </ul>"},{"location":"challenges/overview/","title":"Overview","text":"Challenges in Token Refresh and Permissions <ol> <li> <p>Handling Refresh Tokens:</p> <p>Managing the refresh token flow smoothly is difficult. You must ensure that the refresh operation doesn\u2019t block other requests or cause a race condition (i.e., multiple refreshes or re-authentication at the same time).</p> </li> <li> <p>UI and UX:</p> <p>Managing the user\u2019s experience during token refresh is tricky. A smooth transition, like showing a loading spinner or auto-refreshing, can improve the experience.</p> </li> <li> <p>Security Concerns:</p> <p>Storing sensitive information like JWT tokens in localStorage can expose you to XSS attacks. It's often safer to use HttpOnly cookies with Secure and SameSite flags.</p> </li> <li> <p>Handling Permissions Efficiently:</p> <p>Making sure that permissions are updated properly throughout the application when user roles change, without making too many requests to the server. Having clear and well-defined permission management at both the frontend and backend is crucial.</p> </li> </ol> Summary <ul> <li>Token Refresh Flow: Implementing a refresh token mechanism in React and RTK Query allows you to keep the user logged in while their session token is refreshed in the background, without requiring a re-login.</li> <li>Permissions: Managing user roles and permissions within the frontend ensures that users can only access features they are authorized to use. This can be easily controlled by using React Context or Redux combined with data fetched from APIs via RTK Query.</li> <li>Challenges: Handling race conditions during token refresh, securely storing tokens, and managing permissions correctly are key challenges to address.</li> </ul>"},{"location":"challenges/overview/#frontend-challenges","title":"Frontend Challenges","text":"<p>Here are some common front-end challenges you might face when working with React:</p> <ol> <li> <p>State Management</p> <ul> <li>Challenge: React\u2019s state management can become complex in large applications. Managing state across multiple components, especially in deeply nested component trees, can be cumbersome.</li> <li> <p>Solution:</p> <ul> <li>Use Context API for global state.</li> <li>Use state management libraries like <code>Redux</code>, <code>Recoil</code>, or <code>Zustand</code> for more scalable solutions.</li> </ul> </li> </ul> </li> <li> <p>Component Reusability</p> <ul> <li>Challenge: Creating reusable components is important, but structuring them in a way that remains flexible without becoming overly complex can be difficult.</li> <li> <p>Solution:</p> <ul> <li>Break components into smaller, more modular pieces.</li> <li>Use Higher-Order Components (HOCs) or Render Props for shared functionality.</li> <li>Use React Hooks to manage logic across components.</li> </ul> </li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Challenge: React apps can become slow as they grow, especially with a lot of components re-rendering unnecessarily.</li> <li> <p>Solution:</p> <ul> <li>Use <code>React.memo</code> to avoid unnecessary re-renders.</li> <li>Use <code>useCallback</code> and <code>useMemo</code> hooks to memoize functions and values.</li> <li>Lazy load components using <code>React.lazy</code> and Suspense for code splitting.</li> </ul> </li> </ul> </li> <li> <p>Handling Side Effects</p> <ul> <li>Challenge: Managing side effects like data fetching, DOM manipulation, etc., can be tricky.</li> <li> <p>Solution:</p> <ul> <li>Use <code>useEffect</code> hook to handle side effects.</li> <li>Use <code>React Query</code> or <code>SWR</code> for handling data fetching and caching more efficiently.</li> </ul> </li> </ul> </li> <li> <p>Form Handling</p> <ul> <li>Challenge: Managing form input states, validation, and submission can quickly get complex, especially with multiple fields and validation rules.</li> <li> <p>Solution:</p> <ul> <li>Use <code>Formik</code> or <code>React Hook Form</code> to manage forms with less boilerplate.</li> <li>Use <code>Yup</code> for schema-based validation.</li> </ul> </li> </ul> </li> <li> <p>Accessibility (a11y)</p> <ul> <li>Challenge: Ensuring your application is accessible to users with disabilities can be a time-consuming process.</li> <li> <p>Solution:</p> <ul> <li>Use semantic HTML and ARIA (Accessible Rich Internet Applications) attributes.</li> <li>Use tools like <code>React Axe</code> to help identify accessibility issues.</li> <li>Ensure your app is keyboard navigable and screen reader-friendly.</li> </ul> </li> </ul> </li> <li> <p>Handling Routing</p> <ul> <li>Challenge: Handling navigation and dynamic routing efficiently in React apps can be challenging, especially with nested routes.</li> <li> <p>Solution:</p> <ul> <li>Use <code>React Router</code> for declarative routing.</li> <li>Dynamically load routes as necessary for better performance.</li> </ul> </li> </ul> </li> <li> <p>Testing Components</p> <ul> <li>Challenge: Writing tests for React components, especially when dealing with hooks and asynchronous code, can be tricky.</li> <li> <p>Solution:</p> <ul> <li>Use <code>Jest</code> for testing and <code>React Testing Library</code> for testing components with a focus on behavior over implementation.</li> <li>Mock external dependencies and side effects using <code>jest.mock</code>.</li> </ul> </li> </ul> </li> <li> <p>CSS Management</p> <ul> <li>Challenge: As React apps grow, managing styles can become difficult. You may end up with too many styles or face issues with CSS-in-JS libraries.</li> <li> <p>Solution:</p> <ul> <li>Use CSS modules or styled-components for scoped styling.</li> <li>Consider using SASS/SCSS for more powerful CSS capabilities.</li> <li>Leverage CSS-in-JS solutions for component-level styling.</li> </ul> </li> </ul> </li> <li> <p>Server-Side Rendering (SSR) / Static Site Generation (SSG)</p> <ul> <li>Challenge: Optimizing React applications for SEO and faster initial load can be difficult without proper server-side rendering or static site generation.</li> <li> <p>Solution:</p> <ul> <li>Use Next.js, which provides built-in support for SSR and SSG.</li> <li>Implement server-side rendering using ReactDOMServer.</li> </ul> </li> </ul> </li> <li> <p>Handling Large Applications</p> <ul> <li>Challenge: Large applications can quickly become difficult to maintain if not properly structured.</li> <li> <p>Solution:</p> <ul> <li>Use Atomic Design principles to break your app into manageable components.</li> <li>Adopt modular and feature-based folder structures.</li> <li>Use code splitting to improve performance.</li> </ul> </li> </ul> </li> <li> <p>Handling Errors and Debugging</p> <ul> <li>Challenge: React\u2019s error boundaries and debugging tools can sometimes be difficult to use in larger applications.</li> <li> <p>Solution:</p> <ul> <li>Use Error Boundaries to catch errors in React components.</li> <li>Use React DevTools for debugging state, hooks, and props.</li> </ul> </li> </ul> </li> <li> <p>Asynchronous Operations</p> <ul> <li>Challenge: Managing async operations like API requests, delays, and error handling can lead to complex and hard-to-maintain code.</li> <li> <p>Solution:</p> <ul> <li>Use <code>async/await</code> or <code>Promises</code> for handling asynchronous code.</li> <li>Implement <code>loading states</code>, <code>error handling</code>, and <code>retry logic</code> when dealing with API requests.</li> </ul> </li> </ul> </li> <li> <p>Internationalization (i18n)</p> <ul> <li>Challenge: Supporting multiple languages in your app can lead to code duplication and complexity.</li> <li> <p>Solution:</p> <ul> <li>Use libraries like <code>react-i18next</code> or <code>react-intl</code> to manage translations.</li> <li>Ensure that your UI is flexible enough to handle different languages (e.g., RTL languages).</li> </ul> </li> </ul> </li> <li> <p>Code Splitting</p> <ul> <li>Challenge: Without proper code splitting, a large application can become slow to load as all JS files are bundled together.</li> <li> <p>Solution:</p> <ul> <li>Use <code>React.lazy</code> and <code>Suspense</code> to load components lazily.</li> <li>Implement <code>Webpack</code> or <code>Vite</code> to split code into smaller, more manageable chunks.</li> </ul> </li> </ul> </li> </ol> <p>By recognizing these challenges early and using the right strategies and tools, you can effectively tackle most front-end development hurdles in React!</p>"},{"location":"challenges/permission-based/","title":"Permission Based","text":"<p>How can I dynamically update user permissions in a React app using RTK Query, especially when permissions change after login? Currently, I store user permissions in <code>localStorage</code> after login, but if the permissions change, the changes are not applied immediately in the app. How can I handle this issue?</p>"},{"location":"challenges/permission-based/#overview","title":"Overview","text":"<p>You're storing user permissions in <code>localStorage</code> after login, but you\u2019re running into an issue where if the user's permissions change (e.g., through an admin action or other event), the changes aren\u2019t reflected in the app until the user logs out and logs back in. This is because you're only setting permissions when the user logs in, and you aren\u2019t fetching or updating them dynamically after the initial login.</p> Problem Recap <ul> <li>Current behavior: Permissions are set in <code>localStorage</code> on login. If permissions change, the UI does not reflect those changes immediately.</li> <li>The issue: Once permissions are set in <code>localStorage</code>, they\u2019re not updated unless the user logs out and logs in again.</li> <li>Goal: Dynamically update the UI and permissions whenever they change, without requiring a re-login.</li> </ul> Key Takeaways <ul> <li>Store Permissions Dynamically: Fetch and update permissions at key moments (login, token refresh, role change).</li> <li>Poll Permissions if Needed: Periodically or based on specific actions (e.g., admin changes), refresh the permissions from the server.</li> <li>Store in State: Use Redux or React Context to store permissions, ensuring that changes are reflected across the app immediately.</li> <li>Invalidate Cache: Use <code>RTK Query</code>'s cache invalidation and re-fetch mechanisms to keep permissions up-to-date in real-time.</li> </ul> <ul> <li>Real-time Updates: To handle permission changes, fetch permissions from the backend regularly or trigger a re-fetch after key events (e.g., role changes).</li> <li>Centralized State: Store permissions in Redux or React Context, not just in <code>localStorage</code>. This ensures they are always up-to-date across the app.</li> <li>Re-fetch Mechanism: Use RTK Query's <code>invalidateTags</code> or re-fetch hooks to update permissions when needed.</li> <li>UI Updates: Use the permissions data in Redux/Context to conditionally render parts of the UI, ensuring the app reflects the latest permissions in real-time.</li> </ul>"},{"location":"challenges/permission-based/#permission-api","title":"Permission API","text":"<p>For your permission API, where you're likely checking or updating permissions (and possibly user roles or access control), the choice of polling technique depends on how often the data changes and how \"real-time\" the updates need to be. Let's break down your use case and recommend the best approach for polling:</p> Key Considerations for Permission API <ul> <li>Frequency of Changes: Are the permissions changing frequently, or are updates more sporadic (e.g., changes might only happen occasionally)?</li> <li>Real-Time Needs: Do other clients need to reflect permission changes in real-time? For example, if one user\u2019s permissions are updated, should all clients reflect that immediately?</li> <li>Resource Efficiency: You want to avoid unnecessary requests when there\u2019s no new data, as polling can increase server load.</li> </ul>"},{"location":"challenges/permission-based/#recommendation-based-on-the-polling-types","title":"Recommendation Based on the Polling Types:","text":""},{"location":"challenges/permission-based/#1-regular-polling-simple-polling","title":"1. Regular Polling (Simple Polling):","text":"When to use <ul> <li>If your permission data changes at regular intervals (e.g., roles or permissions are updated frequently across users or roles).</li> <li>If updates are important to be reflected often but don\u2019t need to be instantaneous.</li> <li>Example: Permissions are refreshed every 5 seconds, and you want the data to reflect those updates regularly, but not necessarily in real-time.</li> </ul> <ul> <li> <p>Why it's good for your use case: If permissions are updated frequently and consistency is crucial, regular polling could work well, as it allows you to automatically fetch the most up-to-date permissions at set intervals.</p> </li> <li> <p>RTK Query Implementation (Simple Polling):</p> <pre><code>import { useGetPermissionsQuery } from \"./services/api\"; // Assuming you have an API    service created with RTK Query\n\nconst Permissions = () =&gt; {\n  const { data, error, isLoading } = useGetPermissionsQuery(undefined, {\n    pollingInterval: 5000, // Poll every 5 seconds to get updated permissions\n  });\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading permissions.&lt;/div&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;Permissions&lt;/h3&gt;\n      &lt;p&gt;{data.permissions}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Permissions;\n</code></pre> </li> </ul>"},{"location":"challenges/permission-based/#2-long-polling","title":"2. Long Polling:","text":"When to use <ul> <li>If your permission updates are less frequent but need to be reflected immediately when they do change.</li> <li>If you want to avoid wasting resources by polling continuously, but still want near real-time updates when permissions change.</li> <li>Example: A user\u2019s permissions only change when an admin updates them, so the client should wait for changes without constantly requesting data.</li> </ul> <ul> <li> <p>Why it's good for your use case: Long polling allows you to wait until permissions are updated (instead of polling at fixed intervals). Once a change is detected, the server sends the update to the client, and the client immediately requests the next update. This avoids frequent unnecessary requests.</p> </li> <li> <p>Implementation with RTK Query: RTK Query doesn\u2019t directly support long polling, but you can simulate it by using the <code>refetch</code> function to re-fetch data when needed.</p> <pre><code>import React, { useEffect, useState } from \"react\";\nimport { useGetPermissionsQuery } from \"./services/api\";\n\nconst Permissions = () =&gt; {\n  const { data, error, isLoading, refetch } = useGetPermissionsQuery();\n  const [isPolling, setIsPolling] = useState(true);\n\n  useEffect(() =&gt; {\n    if (!isPolling) return;\n    const interval = setInterval(() =&gt; {\n      refetch(); // Manually trigger the refetch\n    }, 5000); // Poll every 5 seconds\n\n    return () =&gt; clearInterval(interval); // Clean up interval on component unmount\n  }, [isPolling, refetch]);\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading permissions.&lt;/div&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;Permissions&lt;/h3&gt;\n      &lt;p&gt;{data.permissions}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setIsPolling(!isPolling)}&gt;\n        {isPolling ? \"Stop Polling\" : \"Start Polling\"}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Permissions;\n</code></pre> </li> </ul>"},{"location":"challenges/permission-based/#3-exponential-backoff-polling","title":"3. Exponential Backoff Polling:","text":"When to use <ul> <li>If permission updates are very sporadic and not expected at fixed intervals.</li> <li>You want to reduce unnecessary load on the server during periods when no updates are expected.</li> </ul> <ul> <li> <p>Why it's good for your use case: If permission updates are rare, exponential backoff polling can help you reduce the frequency of requests over time, adjusting the polling interval based on the activity and the number of updates.</p> </li> <li> <p>Implementation Considerations: You will need to manage the backoff logic yourself (perhaps with custom state or logic to adjust the polling intervals).</p> </li> </ul>"},{"location":"challenges/permission-based/#best-option-for-your-permission-api","title":"Best Option for Your Permission API:","text":"<p>Given the use case for permissions:</p> <ul> <li>If permission updates are expected regularly, regular polling is the most straightforward solution for ensuring all clients have the latest data.</li> <li>If permission updates are infrequent but need to be reflected immediately, consider long polling to minimize unnecessary server requests while still ensuring near real-time data updates.</li> <li>If permission updates are rare, using exponential backoff polling can save resources by increasing the interval between requests over time.</li> </ul>"},{"location":"challenges/permission-based/#suggested-approach-with-rtk-query","title":"Suggested Approach with RTK Query:","text":"<ol> <li> <p>Regular Polling is most commonly used when the data changes at predictable intervals. This works best with RTK Query as you can easily implement the <code>pollingInterval</code> option for automatic periodic fetching.</p> </li> <li> <p>Long Polling can be simulated using RTK Query's <code>refetch</code> method, but you'll need to handle it manually for better control over when to request the next set of data.</p> </li> </ol> <p>Conclusion</p> <p>For your permission API, regular polling is likely the best approach if permissions need to be checked regularly (e.g., every few seconds) and updates must be reflected in real-time across all devices. However, if updates are infrequent, long polling or exponential backoff could be better choices.</p>"},{"location":"challenges/real-time-update/","title":"Real Time","text":"<p>Ah, I understand now! You're asking if the changes made by one user in their browser (for example, on their laptop) will automatically propagate to other users\u2019 browsers without them having to hit the API again. This is a real-time synchronization issue, and RTK Query, by itself, is not designed to handle real-time updates across multiple clients directly, as it's optimized for fetching and caching data from APIs.</p> <p>However, you can achieve this behavior using WebSockets, Server-Sent Events (SSE), or similar real-time communication methods to ensure that when one user updates something, the data is immediately propagated to all other users without them needing to refresh or poll the API.</p> Here's how you can approach this <ol> <li> <p>WebSockets (or SSE): Use WebSockets (or Server-Sent Events) to establish a real-time connection between the browser and the server. When one user makes a change, the server will push the update to all other connected clients (users).</p> </li> <li> <p>RTK Query + WebSockets: You can use RTK Query to fetch and cache data from the API, but for real-time updates, you would handle the WebSocket connection separately and then update the cache of RTK Query whenever the data changes (pushed from the server).</p> </li> </ol>"},{"location":"challenges/real-time-update/#steps-to-implement","title":"Steps to implement:","text":""},{"location":"challenges/real-time-update/#1-setting-up-websocket-communication","title":"1. Setting up WebSocket Communication","text":"<p>First, you need to establish a WebSocket connection that will send updates to all connected clients when a device's state changes.</p> <p>For example, your server would notify all connected clients when one device's status changes:</p> <ul> <li>Server-side: When a device status changes (on any user's device), the server sends a message to all connected clients via WebSockets.</li> <li>Client-side: Each client (browser) listens to this WebSocket connection and updates its state when a change occurs.</li> </ul>"},{"location":"challenges/real-time-update/#2-rtk-query-for-data-fetching-websocket-for-real-time-sync","title":"2. RTK Query for Data Fetching + WebSocket for Real-time Sync","text":"<p>You can continue using RTK Query for fetching the device data, but when you receive real-time updates from WebSocket, you will manually update the cached data in RTK Query to propagate the changes.</p>"},{"location":"challenges/real-time-update/#example-setup","title":"Example Setup:","text":""},{"location":"challenges/real-time-update/#1-websocket-connection-in-a-react-component-client-side","title":"1. WebSocket Connection in a React Component (Client-side)","text":"<pre><code>import React, { useEffect, useState } from \"react\";\nimport { useGetDeviceDataQuery } from \"../services/api\"; // RTK Query hook\n\nlet socket;\n\nconst DeviceList = () =&gt; {\n  const { data: devices, error, isLoading } = useGetDeviceDataQuery();\n  const [deviceData, setDeviceData] = useState(devices);\n\n  // Initialize WebSocket connection\n  useEffect(() =&gt; {\n    socket = new WebSocket(\"ws://yourserver.com/devices\"); // WebSocket server URL\n\n    socket.onopen = () =&gt; {\n      console.log(\"WebSocket connected!\");\n    };\n\n    // Listen for messages from WebSocket\n    socket.onmessage = (event) =&gt; {\n      const updatedDevice = JSON.parse(event.data); // The device data sent by the server\n\n      // When a device update comes through, update the local state\n      setDeviceData((prevData) =&gt;\n        prevData.map((device) =&gt;\n          device.id === updatedDevice.id ? updatedDevice : device\n        )\n      );\n    };\n\n    // Cleanup WebSocket on unmount\n    return () =&gt; {\n      socket.close();\n    };\n  }, []);\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n  // Display the devices list\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Devices&lt;/h2&gt;\n      {deviceData?.map((device) =&gt; (\n        &lt;div key={device.id}&gt;\n          &lt;h3&gt;{device.name}&lt;/h3&gt;\n          &lt;p&gt;Status: {device.status}&lt;/p&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default DeviceList;\n</code></pre>"},{"location":"challenges/real-time-update/#2-server-side-websocket-broadcasting-nodejs-example","title":"2. Server-Side WebSocket Broadcasting (Node.js Example)","text":"<p>On the server side, when a device status is updated by one user, the server will broadcast that update to all connected clients via WebSocket.</p> <p>Here\u2019s a <code>Node.js</code> WebSocket server example:</p> <pre><code>const WebSocket = require(\"ws\");\nconst wss = new WebSocket.Server({ port: 8080 }); // WebSocket server\n\n// Store connected clients\nlet clients = [];\n\nwss.on(\"connection\", (ws) =&gt; {\n  clients.push(ws); // Add new client to the list\n\n  // When a message (device update) is received, broadcast to all clients\n  ws.on(\"message\", (message) =&gt; {\n    const deviceUpdate = JSON.parse(message);\n\n    // Broadcast to all clients\n    clients.forEach((client) =&gt; {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(JSON.stringify(deviceUpdate)); // Send updated device data\n      }\n    });\n  });\n\n  // Remove the client from the list when they disconnect\n  ws.on(\"close\", () =&gt; {\n    clients = clients.filter((client) =&gt; client !== ws);\n  });\n});\n</code></pre>"},{"location":"challenges/real-time-update/#3-how-it-works","title":"3. How it Works:","text":"<ul> <li>When one user updates a device (for example, toggling a status from <code>on</code> to <code>off</code>), the server receives the update and then pushes the update to all connected WebSocket clients.</li> <li>All other clients (users on different laptops) will receive the updated device data via the WebSocket connection, and they will immediately update the device\u2019s state in their UI.</li> <li>The WebSocket connection allows the device list to stay in sync without making additional API requests.</li> </ul>"},{"location":"challenges/real-time-update/#4-handling-updates-in-rtk-query-cache","title":"4. Handling Updates in RTK Query Cache","text":"<p>Once you receive a WebSocket message on the client, you can use RTK Query\u2019s cache update methods to ensure the state in the Redux store stays in sync.</p> <p>Here\u2019s how you could use <code>updateQueryData</code> to manually update the cache:</p> <pre><code>import { deviceApi } from \"../services/api\";\n\n// WebSocket message handler\nsocket.onmessage = (event) =&gt; {\n  const updatedDevice = JSON.parse(event.data);\n\n  // Use the updateQueryData function to update the cache directly\n  dispatch(\n    deviceApi.util.updateQueryData(\"getDeviceData\", undefined, (draft) =&gt; {\n      const index = draft.findIndex((device) =&gt; device.id === updatedDevice.id);\n      if (index !== -1) {\n        draft[index] = updatedDevice; // Update the device in the cache\n      }\n    })\n  );\n};\n</code></pre> Summary <ul> <li>WebSocket/SSE is the key to achieving real-time communication across users' browsers. Once a WebSocket connection is established between the clients and the server, updates can be sent to all clients when one user updates the data.</li> <li>RTK Query handles the data fetching and caching, while you use WebSockets to push real-time updates to all clients and update the local cache.</li> <li>No API hit is required after the initial data is fetched. All subsequent updates happen in real-time through WebSocket connections.</li> </ul> <p>This ensures that when one user changes something (e.g., updates the status of a device), the other users will see the changes immediately, without needing to refresh or hit the API again.</p>"},{"location":"challenges/real-time-update/#alternative-to-websockets","title":"Alternative to websockets","text":"<p>The best approach depends on your app's architecture, how real-time you need the data to be, and the complexity you're willing to manage. For most use cases without WebSockets, SSE or Polling should suffice.</p> Tip <p>Here\u2019s a summary of alternative real-time communication technologies you can consider instead of WebSockets:</p> <ul> <li>Server-Sent Events (SSE) \u2013 For server-to-client real-time communication (one-way).</li> <li>Long Polling \u2013 For mimicking real-time behavior with periodic requests.</li> <li>Polling \u2013 For periodic checks for updates at fixed intervals.</li> <li> <p>Push Notifications \u2013 For notifying users about updates even when they\u2019re not actively using the app.</p> </li> <li> <p>Firebase Realtime Database/Firestore \u2013 For real-time synchronization in mobile/web apps without managing WebSockets.</p> </li> <li>GraphQL Subscriptions \u2013 Real-time data syncing for GraphQL-based apps.</li> <li>MQTT \u2013 For IoT or low-bandwidth applications.</li> <li>WebRTC \u2013 For peer-to-peer communication (audio/video and data).</li> <li>gRPC with Bidirectional Streaming \u2013 High-performance real-time communication.</li> <li> <p>Pusher \u2013 A managed service for WebSocket-like real-time communication.</p> </li> <li> <p>Redis Pub/Sub \u2013 For event-driven real-time systems in distributed applications.</p> </li> </ul> <p>Choosing the best alternative depends on your use case, complexity, and scale requirements. Each method has its advantages and trade-offs.</p>"},{"location":"challenges/refetch-in-rtk-query/","title":"Forcing a Refetch in RTK Query: How to Always Hit the API","text":"<p>In RTK Query (Redux Toolkit Query), by default, it caches responses for a specific query and doesn't refetch the data if the same request with the same parameters is made. This is done to avoid unnecessary network requests and optimize performance. However, if you need to refetch the API every time (even if the request is the same), you can override the caching behavior.</p>"},{"location":"challenges/refetch-in-rtk-query/#retching-api-methods","title":"Retching API Methods","text":"<p>There are several ways to force RTK Query to always hit the API:</p>"},{"location":"challenges/refetch-in-rtk-query/#1-forcerefetch-option","title":"1. <code>forceRefetch</code> option","text":"<p>You can use the <code>forceRefetch</code> option by setting it to <code>true</code> when making the request. This will force a refetch of the data even if the query is already cached.</p> <pre><code>const { data, error, isLoading } = useGetMyDataQuery(id, {\n  refetchOnMountOrArgChange: true, // This forces a refetch when the component mounts or the argument changes\n  refetchOnFocus: true, // Optional: refetch when the window gets focused\n  refetchOnReconnect: true, // Optional: refetch when reconnecting the network\n});\n</code></pre>"},{"location":"challenges/refetch-in-rtk-query/#2-use-skip-and-trigger-with-uselazyquery","title":"2. Use <code>skip</code> and <code>trigger</code> with <code>useLazyQuery</code>","text":"<p>You can manually trigger the refetch of data using <code>useLazyQuery</code>. This is useful if you need more control over when the API request is fired, such as on a button click or a certain event.</p> <pre><code>const [trigger, { data, isLoading, error }] = useLazyGetMyDataQuery();\n\nconst handleRefetch = () =&gt; {\n  trigger({ id }); // Force a refetch\n};\n</code></pre>"},{"location":"challenges/refetch-in-rtk-query/#3-refetch-with-refetch-method","title":"3. Refetch with <code>refetch</code> method","text":"<p>If you want to refetch the query within a component, you can manually trigger a refetch by calling the <code>refetch()</code> method returned by the hook.</p> <pre><code>const { data, error, isLoading, refetch } = useGetMyDataQuery(id);\n\nconst handleRefetch = () =&gt; {\n  refetch(); // Force a refetch\n};\n</code></pre>"},{"location":"challenges/refetch-in-rtk-query/#4-disable-caching-for-a-specific-query","title":"4. Disable caching for a specific query","text":"<p>If you want to completely disable caching and refetch every time, you can modify the <code>keepUnusedDataFor</code> option in your query's configuration:</p> <pre><code>const { data, error, isLoading } = useGetMyDataQuery(id, {\n  keepUnusedDataFor: 0, // This makes the cache expire immediately\n});\n</code></pre> <p>This will make sure that the data isn't cached and will always trigger an API request every time the query is fired.</p>"},{"location":"challenges/refetch-in-rtk-query/#5-use-polling-for-interval-based-refetch","title":"5. Use <code>polling</code> (for interval-based refetch)","text":"<p>If you want to refetch data at specific intervals, you can use polling with the <code>pollingInterval</code> option.</p> <pre><code>const { data, error, isLoading } = useGetMyDataQuery(id, {\n  pollingInterval: 10000, // Refetch every 10 seconds\n});\n</code></pre> <p>This is useful if you want to keep your data up to date by hitting the API regularly.</p> Summary <ul> <li>Use <code>refetchOnMountOrArgChange</code>, <code>refetchOnFocus</code>, or <code>refetchOnReconnect</code> for automatic refetching.</li> <li>Use <code>useLazyQuery</code> or <code>refetch</code> for manual triggering.</li> <li>Adjust <code>keepUnusedDataFor</code> to control cache expiration.</li> <li>Polling can be set if you want periodic refetching.</li> </ul> <p>Choose the approach based on your requirements for fetching data repeatedly.</p>"},{"location":"challenges/refetch-in-rtk-query/#best-method-to-choose","title":"Best Method to Choose","text":"<p>The best method depends on your specific use case, but here are some guidelines:</p>"},{"location":"challenges/refetch-in-rtk-query/#1-if-you-need-to-refetch-automatically-whenever-the-component-mounts-or-the-argument-changes","title":"1. If you need to refetch automatically whenever the component mounts or the argument changes:","text":"<ul> <li> <p>Best Method: Use <code>refetchOnMountOrArgChange</code>.</p> <pre><code>const { data, error, isLoading } = useGetMyDataQuery(id, {\n  refetchOnMountOrArgChange: true,\n});\n</code></pre> </li> <li> <p>Why it's best: This method is built into RTK Query to automatically refetch the data whenever the query's parameters change or the component remounts. It\u2019s the simplest and most efficient method for ensuring that your data is always fresh.</p> </li> </ul>"},{"location":"challenges/refetch-in-rtk-query/#2-if-you-need-more-manual-control-over-when-to-refetch","title":"2. If you need more manual control over when to refetch:","text":"<ul> <li> <p>Best Method: Use <code>useLazyQuery</code> with <code>trigger</code> or the <code>refetch</code> function.</p> <pre><code>const [trigger, { data, isLoading, error }] = useLazyGetMyDataQuery();\nconst handleRefetch = () =&gt; {\n  trigger({ id });\n};\n</code></pre> </li> <li> <p>Why it's best: This approach gives you full control over when the refetch happens (e.g., on button clicks, user actions, or other events). It\u2019s ideal for scenarios where you need to trigger the request manually instead of automatically.</p> </li> </ul>"},{"location":"challenges/refetch-in-rtk-query/#3-if-you-want-to-completely-disable-caching-and-always-make-a-network-request","title":"3. If you want to completely disable caching and always make a network request:","text":"<ul> <li> <p>Best Method: Set <code>keepUnusedDataFor</code> to <code>0</code>.</p> <pre><code>const { data, error, isLoading } = useGetMyDataQuery(id, {\n  keepUnusedDataFor: 0,\n});\n</code></pre> </li> <li> <p>Why it's best: This method ensures that the data is never cached and always triggers an API request. It\u2019s useful if you want to completely bypass the cache for a particular query, but be cautious as this can lead to performance issues if overused.</p> </li> </ul> Conclusion <ul> <li>Use <code>refetchOnMountOrArgChange</code> if you want automatic, effortless refetching.</li> <li>Use <code>useLazyQuery</code> if you need to control when the query is triggered.</li> <li>Use <code>keepUnusedDataFor</code>: 0 if you want to completely disable caching.</li> </ul> <p>For most use cases, <code>refetchOnMountOrArgChange</code> is the best method because it balances simplicity with automatic refetching.</p>"},{"location":"challenges/refresh-token/","title":"Refresh Token","text":"<p>These are included as <code>api.util</code> inside the API object.</p>"},{"location":"challenges/refresh-token/#apiutil","title":"api.util","text":"<p>In RTK Query (Redux Toolkit Query), <code>api.util</code> refers to a set of utilities that can be used for caching and optimistic updates within the API service. It's an important feature when working with Redux Toolkit and RTK Query because it allows you to interact with the cache, trigger refetches, and update the store, making it easier to manage the state of your app with API calls.</p> <p>Here\u2019s a breakdown of <code>api.util</code>:</p> <ol> <li> <p><code>api.util.updateQueryData</code></p> <p>This method allows you to optimistically update the data in the Redux store for a particular query. It is useful when you want to modify or update the data in the cache without making an actual API call (e.g., when performing optimistic updates).</p> <pre><code>api.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n  draft.push(newPost); // Add a new post to the cached data\n});\n</code></pre> <ul> <li><code>'getPosts'</code> is the name of the query endpoint.</li> <li><code>undefined</code> is used when the query does not take any parameters.</li> <li>The <code>draft</code> is the mutable data of the query that you can update.</li> </ul> </li> <li> <p><code>api.util.invalidateTags</code></p> <p>This utility helps you invalidate the cache for specific tags, triggering a refetch of the relevant data. It's typically used when you want to refresh certain data after a mutation (e.g., after a successful update, delete, or create operation).</p> <pre><code>api.util.invalidateTags([{ type: \"Post\", id: newPost.id }]);\n</code></pre> <ul> <li>This invalidates a cache entry for a <code>Post</code> with the given <code>id</code>.</li> <li>This triggers a refetch for the specific <code>Post</code> if it\u2019s being used in a component.</li> </ul> </li> <li> <p><code>api.util.resetApiState</code></p> <p>This method is used to reset the entire API state in the Redux store. It can be useful when you want to clear all cached data, for example, when the user logs out.</p> <pre><code>api.util.resetApiState();\n</code></pre> </li> <li> <p><code>api.util.select()</code>, <code>api.util.selectQueryData()</code></p> <p>These methods help you select specific data from the API cache, allowing you to access and inspect cached data directly from the Redux store.</p> </li> </ol>"},{"location":"challenges/refresh-token/#when-to-use-apiutil","title":"When to Use api.util:","text":"<ul> <li>Optimistic updates: When you want to make an update to the cache before the mutation request finishes (e.g., showing an updated list of posts right after creating a new one).</li> <li>Cache invalidation: To ensure that the cache is updated and that the next time a query is made, the data is fresh (e.g., after a successful mutation).</li> <li>Clearing cache: When resetting the application state (like when logging out).</li> <li>Refetching data: After performing certain actions like adding, updating, or deleting items, it may be necessary to refresh the associated data to reflect those changes.</li> </ul>"},{"location":"challenges/refresh-token/#example-scenario","title":"Example Scenario:","text":"<p>Suppose you have a <code>getPosts</code> query and a <code>createPost</code> mutation. When you create a new post, you may want to optimistically add the post to the cache without waiting for the API request to finish. Then, after the mutation finishes, you can invalidate the cache for <code>getPosts</code> to make sure the list is refreshed.</p> <pre><code>const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api/\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"posts\",\n      providesTags: (result) =&gt;\n        result ? [...result.map(({ id }) =&gt; ({ type: \"Post\", id }))] : [],\n    }),\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n      // Optimistically update the cache\n      onQueryStarted: async (newPost, { dispatch, queryFulfilled }) =&gt; {\n        // Optimistically update the cache\n        dispatch(\n          postsApi.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n            draft.push(newPost); // Add the new post optimistically\n          })\n        );\n        try {\n          await queryFulfilled;\n        } catch (err) {\n          // Handle error if needed\n        }\n      },\n      // Invalidate cache after mutation\n      onSuccess: () =&gt; {\n        dispatch(postsApi.util.invalidateTags([{ type: \"Post\" }]));\n      },\n    }),\n  }),\n});\n</code></pre> <p>In the above example:</p> <ul> <li><code>onQueryStarted</code> is used to optimistically update the <code>getPosts</code> cache before the mutation completes.</li> <li><code>onSuccess</code> invalidates the cache to ensure the data is fresh after the mutation.</li> </ul> <p>Conclusion</p> <p><code>api.util</code> in RTK Query is a powerful tool that gives you control over how you interact with your API's cache and manage refetching, updating, and invalidating data in a Redux store. It simplifies common tasks like handling optimistic updates, cache invalidation, and direct data updates, making it easier to keep your app's state in sync with the server.</p>"},{"location":"challenges/refresh-token/#api-slices-react-hooks","title":"API Slices: React Hooks","text":"<p>RTK Query provides additional hooks for more advanced use-cases, although not all are generated directly on the Api object as well. The full list of hooks generated in the React-specific version of <code>createApi</code> is as follows:</p> <ul> <li><code>useQuery</code> (endpoint-specific, also generated on the Api object)</li> <li><code>useMutation</code> (endpoint-specific, also generated on the Api object)</li> <li><code>useQueryState</code> (endpoint-specific)</li> <li><code>useQuerySubscription</code> (endpoint-specific)</li> <li><code>useLazyQuery</code> (endpoint-specific, also generated on the Api object)</li> <li><code>useLazyQuerySubscription</code> (endpoint-specific)</li> <li><code>usePrefetch</code> (endpoint-agnostic)</li> </ul> <ul> <li>Official, API Slices: Utilities</li> <li>Official, API Slices: React Hooks</li> </ul>"},{"location":"challenges/token-monitor/","title":"Token Monitor","text":"<p>When it comes to refreshing tokens in a React app using Redux Toolkit and Axios, the two most common approaches are:</p> <ul> <li>\ud83d\udd01 In Axios interceptors</li> <li>\ud83d\udd01 Proactively in React hooks</li> </ul> <p>TL;DR \u2014 Use Axios interceptors for token refresh</p> <ul> <li>\u2705 Best practice: Use an Axios interceptor to catch 401 responses and refresh the token transparently.</li> <li>\ud83d\udd01 Optionally, use a hook to proactively refresh (e.g., before expiry) in special cases like long-lived sessions or silent background refresh.</li> </ul>"},{"location":"challenges/token-monitor/#should-you-do-this-consider-the-following","title":"\u26a0\ufe0f Should you do this? Consider the following:","text":"<ol> <li> <p>Security Risk</p> <ul> <li>If <code>loginFormData</code> contains sensitive credentials (e.g., username/password), storing or reusing it after login could pose a security risk.</li> <li>Ideally, you shouldn\u2019t store plaintext credentials in memory beyond their immediate use.</li> </ul> </li> <li> <p>User Experience</p> <ul> <li>Automatically logging in the user after a refresh failure might confuse the user if credentials have changed or expired.</li> <li>It may also mask issues that should be handled with explicit re-authentication (e.g., prompting the user to log in again).</li> </ul> </li> <li> <p>Silent Failures</p> <ul> <li>If the <code>login()</code> call fails again, what will your fallback be? Without a retry limit or error state handling, this can lead to poor UX.</li> </ul> </li> <li> <p>State Consistency</p> <ul> <li>You\u2019ll need to ensure that any Redux state or context (e.g., <code>setUser</code>, token storage, etc.) is updated accordingly, and that all requests waiting on a token retry are resumed pro</li> </ul> </li> </ol> \u2705 Goal <ul> <li>Persist tokens (and their timestamps) in Redux store using redux-persist</li> <li>Monitor token expiration using <code>exp</code> timestamp</li> <li>Automatically refresh the token before it expires</li> </ul> \ud83e\uddf1 Assumptions <ul> <li>You store JWT tokens (or auth state) in Redux</li> <li>You persist them with <code>redux-persist</code></li> <li>You have an API to refresh the token</li> <li>You use RTK Query or thunk-based middleware</li> </ul>"},{"location":"challenges/token-monitor/#create-token-monitor-eg-in-appjs","title":"\u23f1\ufe0f Create Token Monitor (e.g., in <code>App.js</code>)","text":"<p>You can set up a proactive token refresh interval in your top-level component (e.g., <code>App.jsx</code>).</p> App.jsx<pre><code>import { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport jwtDecode from \"jwt-decode\";\nimport { setCredentials, logout } from \"./features/auth/authSlice\";\nimport { useRefreshTokenMutation } from \"./services/authApi\";\n\nconst App = () =&gt; {\n  const dispatch = useDispatch();\n  const auth = useSelector((state) =&gt; state.auth);\n  const [refreshToken] = useRefreshTokenMutation();\n\n  useEffect(() =&gt; {\n    if (!auth?.accessToken || !auth?.exp) return;\n\n    const refreshThreshold = 60; // seconds before expiration\n    const currentTime = Math.floor(Date.now() / 1000);\n    const timeUntilExpire = auth.exp - currentTime;\n\n    if (timeUntilExpire &lt; refreshThreshold) {\n      // refresh proactively\n      refreshToken({ token: auth.refreshToken })\n        .unwrap()\n        .then((data) =&gt; {\n          const decoded = jwtDecode(data.accessToken);\n          dispatch(\n            setCredentials({\n              accessToken: data.accessToken,\n              refreshToken: data.refreshToken,\n              exp: decoded.exp,\n              iat: decoded.iat,\n              user: data.user,\n            })\n          );\n        })\n        .catch(() =&gt; {\n          dispatch(logout());\n        });\n    }\n\n    const interval = setInterval(() =&gt; {\n      const now = Math.floor(Date.now() / 1000);\n      const expiresIn = auth.exp - now;\n\n      if (expiresIn &lt; refreshThreshold) {\n        refreshToken({ token: auth.refreshToken })\n          .unwrap()\n          .then((data) =&gt; {\n            const decoded = jwtDecode(data.accessToken);\n            dispatch(\n              setCredentials({\n                accessToken: data.accessToken,\n                refreshToken: data.refreshToken,\n                exp: decoded.exp,\n                iat: decoded.iat,\n                user: data.user,\n              })\n            );\n          })\n          .catch(() =&gt; {\n            dispatch(logout());\n          });\n      }\n    }, 30 * 1000); // check every 30 seconds\n\n    return () =&gt; clearInterval(interval);\n  }, [auth, dispatch, refreshToken]);\n\n  return &lt;div&gt;{/* Your routes/components */}&lt;/div&gt;;\n};\n</code></pre> Note <ul> <li>This approach ensures tokens are refreshed just before expiration, using the <code>exp</code> timestamp.</li> <li>You can tune <code>refreshThreshold</code> to control how early to refresh.</li> <li>Make sure your backend sets proper <code>exp</code>/<code>iat</code> in the JWT.</li> </ul>"},{"location":"challenges/token-monitor/#theory","title":"Theory","text":""},{"location":"challenges/token-monitor/#rtk-query-standard-approach","title":"RTK Query Standard Approach","text":"<p>No, using RTK Query\u2019s baseQuery approach alone cannot proactively refresh the token before it expires.</p> Explanation based on search results: <ul> <li> <p>The typical RTK Query baseQuery with token refresh logic works reactively: it detects a 401 Unauthorized response from the server (meaning the access token has expired) and then triggers a refresh token call to get a new token before retrying the original request.</p> </li> <li> <p>This approach does not track token expiry time or refresh the token proactively ahead of expiry. Instead, it waits until the server rejects a request due to an expired token.</p> </li> <li> <p>To refresh tokens before expiry, you need additional logic outside of RTK Query\u2019s baseQuery, such as:</p> <ul> <li>Storing the token expiry timestamp when you receive the token.</li> <li>Using React hooks or middleware with timers (<code>setTimeout</code> or <code>setInterval</code>) to trigger a refresh token request proactively before the token actually expires.</li> </ul> </li> <li> <p>RTK Query\u2019s <code>baseQuery</code> function is synchronous in nature and cannot directly use React hooks (which must be called inside React components or custom hooks), so proactive refresh logic relying on hooks or side effects cannot be implemented purely inside baseQuery.</p> </li> </ul> How to do it with RTK Query <ol> <li> <p>Create a custom baseQuery with re-authentication logic</p> <p>Use <code>fetchBaseQuery</code> wrapped inside a custom function that:</p> <ul> <li>Executes the original query.</li> <li>Checks if the response is a 401 error (token expired).</li> <li>Calls the refresh token endpoint to get a new access token.</li> <li>Updates the token in your store.</li> <li>Retries the original query with the new token.</li> </ul> </li> <li> <p>Use a mutex to prevent multiple simultaneous refresh calls</p> <p>When multiple requests fail with 401 at the same time, use a mutex (e.g., from <code>async-mutex</code>) to ensure only one refresh call happens, preventing race conditions.</p> </li> <li> <p>Inject the updated token into headers dynamically</p> <p>In your baseQuery, read the current token from the store or a token management utility before each request to ensure you always send the latest token.</p> </li> </ol> Example<pre><code>import { fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { Mutex } from \"async-mutex\";\nimport { tokenReceived, loggedOut } from \"./authSlice\";\n\nconst mutex = new Mutex();\n\nconst baseQuery = fetchBaseQuery({ baseUrl: \"/api\" });\n\nconst baseQueryWithReauth = async (args, api, extraOptions) =&gt; {\n  await mutex.waitForUnlock();\n  let result = await baseQuery(args, api, extraOptions);\n\n  if (result.error &amp;&amp; result.error.status === 401) {\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire();\n      try {\n        const refreshResult = await baseQuery(\n          \"/refreshToken\",\n          api,\n          extraOptions\n        );\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data));\n          result = await baseQuery(args, api, extraOptions); // retry original query\n        } else {\n          api.dispatch(loggedOut());\n        }\n      } finally {\n        release();\n      }\n    } else {\n      await mutex.waitForUnlock();\n      result = await baseQuery(args, api, extraOptions);\n    }\n  }\n  return result;\n};\n</code></pre> <p>Summary</p> Aspect RTK Query baseQuery approach Proactive refresh (before expiry) When token is refreshed After receiving 401 Unauthorized response Before token expiry, based on expiry time Mechanism Detect 401 error, call refresh token API Use timers/hooks/middleware outside baseQuery Can <code>baseQuery</code> do proactive refresh? No Requires additional app-level logic <p>Conclusion</p> <p>You cannot rely on RTK Query\u2019s baseQuery alone to refresh tokens before they expire. The <code>baseQuery</code> approach is the recommended standard for reactive refresh on expiry detection, but proactive refresh requires separate logic implemented outside RTK Query, typically using React hooks or middleware that track token expiry and trigger refresh calls in advance.</p>"},{"location":"challenges/token-monitor/#proactive-refresh","title":"Proactive Refresh","text":"Proactive refresh (before expiry) considerations: <ul> <li>To refresh the token before expiry (e.g., based on token expiry time), you would need to track the token's expiration timestamp in your app state.</li> <li>Then, you could implement a timer or background task (outside of RTK Query baseQuery) to call the refresh endpoint proactively.</li> <li>RTK Query\u2019s baseQuery mechanism does not inherently support scheduling refreshes before expiry.</li> <li>Hooks or other side-effect management (e.g., <code>setTimeout</code> in a React component or middleware) are typically used for proactive refresh.</li> </ul> <p>So, if you want to refresh tokens before they expire, you will need additional logic outside of RTK Query\u2019s baseQuery, such as React hooks with timers or middleware. The RTK Query baseQuery approach is the standard and recommended way to handle token refresh reactively on expiry.</p> <p>Summary</p> Approach When token is refreshed Mechanism Reactive refresh (RTK Query baseQuery) After receiving 401 Unauthorized response Custom baseQuery detects 401, triggers refresh token API call, then retries original request Proactive refresh Before token expiry Additional logic outside RTK Query (e.g., React hooks with timers or middleware) to track expiry and refresh token proactively"},{"location":"core/intro/","title":"Intro","text":"<ul> <li>\ud83e\uddf1 Architecture</li> <li>\ud83e\udde9 Micro Frontends</li> <li>\ud83d\udccb Code Guidelines</li> <li>\ud83c\udf10 API Integration</li> <li>\ud83d\udd10 Authentication &amp; Authorization</li> <li>\ud83d\udd00 Routing</li> <li>\ud83d\udd8c\ufe0f UI &amp; Components</li> <li>\ud83d\udcdd Forms &amp; Validation</li> <li>\u26a0\ufe0f Error Handling &amp; Logging</li> <li>\u26a1 Performance Optimization</li> <li>\ud83e\uddea Testing</li> <li>\ud83d\ude80 Deployment</li> <li>\u267f Accessibility</li> <li>\ud83d\udd12 Security</li> <li>\ud83d\udcf1 Progressive Web App (PWA)</li> <li>\ud83c\udf10 Internationalization (i18n)</li> <li>\ud83d\udee0\ufe0f Debugging Guide</li> <li>\ud83e\udd1d Contribution Guide</li> <li>\ud83d\udccb Changelog</li> <li>\u2753 FAQs</li> <li>\ud83d\udcc9 Tech Debt &amp; Future Improvements</li> </ul> <pre><code>give me its content in canvas: in chatgpt\n\nor\n\nguidelines/linting-formatting.md give me its content in canvas\n</code></pre> <p>Youtube: Debug React Apps Like a Pro | Tamil</p>"},{"location":"core/accessibility/best-practices/","title":"Accessibility Best Practices","text":"<p>Creating accessible web applications ensures that all users, including those with disabilities, can use your application effectively. Here are best practices for building accessible React applications:</p>"},{"location":"core/accessibility/best-practices/#1-semantic-html","title":"1. Semantic HTML","text":"<ul> <li>Use semantic HTML elements like <code>&lt;header&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, and <code>&lt;section&gt;</code> to provide a meaningful structure to your content.</li> <li>Avoid using <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> for elements that have a specific semantic purpose (e.g., use <code>&lt;button&gt;</code> for clickable actions).</li> </ul>"},{"location":"core/accessibility/best-practices/#2-aria-accessible-rich-internet-applications-roles-and-attributes","title":"2. ARIA (Accessible Rich Internet Applications) Roles and Attributes","text":"<ul> <li> <p>Use ARIA roles sparingly and only when native elements cannot provide the necessary semantics.</p> </li> <li> <p>Common ARIA roles:</p> <ul> <li><code>role=\"alert\"</code> for live updates or notifications.</li> <li><code>role=\"dialog\"</code> for modal popups.</li> </ul> </li> <li> <p>Avoid overusing ARIA, as improper usage can confuse assistive technologies.</p> </li> </ul>"},{"location":"core/accessibility/best-practices/#3-keyboard-navigation","title":"3. Keyboard Navigation","text":"<ul> <li>Ensure all interactive elements, such as links, buttons, and forms, are accessible via the keyboard.</li> <li>Test the application by navigating using the <code>Tab</code> key, <code>Shift + Tab</code>, and <code>Enter</code> or <code>Space</code> to interact with elements.</li> <li>Use <code>tabindex</code> to manage keyboard focus when needed (e.g., <code>tabindex=\"-1\"</code> to remove an element from the focus order).</li> </ul>"},{"location":"core/accessibility/best-practices/#4-alt-text-for-images","title":"4. Alt Text for Images","text":"<ul> <li>Provide descriptive <code>alt</code> attributes for images to convey their purpose to screen readers.</li> <li> <p>For decorative images, use an empty <code>alt</code> attribute (<code>alt=\"\"</code>).</p> </li> <li> <p>Example:</p> <pre><code>&lt;img src=\"profile.jpg\" alt=\"User profile picture\"&gt;\n</code></pre> </li> </ul>"},{"location":"core/accessibility/best-practices/#5-forms-accessibility","title":"5. Forms Accessibility","text":"<ul> <li>Use <code>&lt;label&gt;</code> elements with <code>for</code> attributes to associate labels with form controls.</li> <li>For custom components, use <code>aria-label</code> or <code>aria-labelledby</code> to describe the input.</li> <li>Provide clear error messages with <code>aria-live</code> regions for validation feedback.</li> </ul>"},{"location":"core/accessibility/best-practices/#6-color-contrast","title":"6. Color Contrast","text":"<ul> <li>Ensure sufficient contrast between text and background colors to make content readable for users with visual impairments.</li> <li>Use tools like WebAIM Contrast Checker to verify color contrast ratios.</li> </ul>"},{"location":"core/accessibility/best-practices/#7-accessible-focus-management","title":"7. Accessible Focus Management","text":"<ul> <li>Ensure focus is managed correctly, especially when dealing with modals or dynamic content.</li> <li>Use focus traps for modals to prevent users from navigating outside the modal.</li> <li>Return focus to the triggering element after the modal is closed.</li> </ul>"},{"location":"core/accessibility/best-practices/#8-skip-links","title":"8. Skip Links","text":"<ul> <li> <p>Add skip links at the top of the page to allow users to bypass repetitive content (e.g., navigation menus) and go directly to the main content.</p> </li> <li> <p>Example:</p> <pre><code>&lt;a href=\"#main-content\" class=\"skip-link\"&gt;Skip to main content&lt;/a&gt;\n&lt;main id=\"main-content\"&gt;...&lt;/main&gt;\n</code></pre> </li> </ul>"},{"location":"core/accessibility/best-practices/#9-accessible-media","title":"9. Accessible Media","text":"<ul> <li>Provide captions and transcripts for video and audio content.</li> <li> <p>Use the <code>&lt;track&gt;</code> element for captions in videos:</p> <pre><code>&lt;video controls&gt;\n&lt;source src=\"video.mp4\" type=\"video/mp4\"&gt;\n&lt;track src=\"captions.vtt\" kind=\"captions\" srclang=\"en\" label=\"English\"&gt;\n&lt;/video&gt;\n</code></pre> </li> </ul>"},{"location":"core/accessibility/best-practices/#10-testing-accessibility","title":"10. Testing Accessibility","text":"<ul> <li>Use automated tools like axe or Lighthouse to identify accessibility issues.</li> <li>Perform manual testing with screen readers (e.g., NVDA, VoiceOver) to ensure a great user experience.</li> </ul>"},{"location":"core/accessibility/best-practices/#11-responsive-design","title":"11. Responsive Design","text":"<ul> <li>Ensure your application is accessible on all devices by using responsive design principles.</li> <li>Use relative units (e.g., <code>em</code>, <code>rem</code>, <code>%</code>) instead of fixed units (e.g., <code>px</code>) for sizing.</li> </ul>"},{"location":"core/accessibility/best-practices/#12-educate-your-team","title":"12. Educate Your Team","text":"<ul> <li>Train developers, designers, and stakeholders on accessibility principles.</li> <li>Incorporate accessibility checks into the development process to catch issues early.</li> </ul> <p>By following these best practices, you can build inclusive applications that provide a great experience for all users.</p>"},{"location":"core/accessibility/testing/","title":"Accessibility Testing","text":"<p>Testing accessibility in web applications ensures that your application meets the needs of all users, including those with disabilities. Below are guidelines and tools for accessibility testing in React applications.</p>"},{"location":"core/accessibility/testing/#1-automated-testing-tools","title":"1. Automated Testing Tools","text":"<p>Automated tools can quickly identify common accessibility issues. While they don't catch everything, they are an excellent starting point.</p>"},{"location":"core/accessibility/testing/#11-lighthouse","title":"1.1 Lighthouse","text":"<ul> <li>Lighthouse is a built-in tool in Chrome DevTools for auditing web applications, including accessibility.</li> </ul> To use <ol> <li>Open DevTools (<code>F12</code> or <code>Ctrl + Shift + I</code> on Windows, <code>Cmd + Option + I</code> on macOS).</li> <li>Go to the Lighthouse tab.</li> <li>Select Accessibility and click Generate Report.</li> </ol>"},{"location":"core/accessibility/testing/#12-axe-browser-extension","title":"1.2 axe Browser Extension","text":"<p>axe is a browser extension for Chrome and Firefox that identifies accessibility issues.</p> Steps <ol> <li>Install the axe extension from the browser's extension store.</li> <li>Open your web application and the axe tool in DevTools.</li> <li>Run the analysis to get a detailed report.</li> </ol>"},{"location":"core/accessibility/testing/#13-eslint-plugin-for-accessibility","title":"1.3 ESLint Plugin for Accessibility","text":"<ul> <li>Use the eslint-plugin-jsx-a11y plugin to catch accessibility issues during development.</li> <li> <p>Install and configure:</p> <pre><code>pnpm add eslint-plugin-jsx-a11y -D\n</code></pre> <p>Add to your ESLint configuration:</p> <pre><code>{\n  \"plugins\": [\"jsx-a11y\"],\n  \"extends\": [\"plugin:jsx-a11y/recommended\"]\n}\n</code></pre> </li> </ul>"},{"location":"core/accessibility/testing/#2-manual-testing","title":"2. Manual Testing","text":"<p>Manual testing ensures that your application is accessible beyond what automated tools can detect.</p>"},{"location":"core/accessibility/testing/#21-keyboard-navigation","title":"2.1 Keyboard Navigation","text":"<ul> <li> <p>Test the app by navigating using the keyboard (<code>Tab</code>, <code>Shift + Tab</code>, <code>Enter</code>, <code>Space</code>):</p> <ul> <li>All interactive elements should be focusable.</li> <li>The focus order should follow a logical sequence.</li> <li>Verify that Esc key closes modals or dropdowns.</li> </ul> </li> </ul>"},{"location":"core/accessibility/testing/#22-screen-reader-testing","title":"2.2 Screen Reader Testing","text":"<ul> <li> <p>Test with popular screen readers:</p> <ul> <li>NVDA (Windows)</li> <li>VoiceOver (macOS/iOS)</li> <li>JAWS (Windows)</li> </ul> </li> <li> <p>Ensure elements are announced correctly and in the proper order.</p> </li> </ul>"},{"location":"core/accessibility/testing/#23-color-contrast-testing","title":"2.3 Color Contrast Testing","text":"<ul> <li> <p>Check that text has sufficient contrast against its backgroun</p> </li> <li> <p>Use tools like:</p> <ul> <li>WebAIM Contrast Checker</li> <li>Chrome DevTools' Accessibility pane.</li> </ul> </li> </ul>"},{"location":"core/accessibility/testing/#24-responsive-design","title":"2.4 Responsive Design","text":"<ul> <li>Test your application on various screen sizes to ensure accessibility on all devices.</li> <li>Ensure touch targets (e.g., buttons) are large enough for users with motor impairments.</li> </ul>"},{"location":"core/accessibility/testing/#3-accessibility-testing-in-cicd-pipelines","title":"3. Accessibility Testing in CI/CD Pipelines","text":"<p>Integrate accessibility testing into your CI/CD workflow to catch issues early.</p>"},{"location":"core/accessibility/testing/#31-axe-core","title":"3.1 axe Core","text":"<ul> <li>Use the axe-core library to programmatically test accessibility.</li> <li> <p>Installation:</p> <pre><code>pnpm add axe-core\n</code></pre> </li> <li> <p>Example Usage:</p> <pre><code>import axe from \"axe-core\";\n\nconst results = await axe.run(document);\nconsole.log(results.violations);\n</code></pre> </li> </ul>"},{"location":"core/accessibility/testing/#32-pa11y","title":"3.2 Pa11y","text":"<ul> <li>Pa11y is an automated accessibility testing tool that integrates well with CI/CD.</li> <li> <p>Installation:</p> <pre><code>pnpm add pa11y -D\n</code></pre> </li> <li> <p>Example:</p> <pre><code>pa11y https://example.com\n</code></pre> </li> </ul>"},{"location":"core/accessibility/testing/#4-testing-with-user-assistive-technology","title":"4. Testing with User Assistive Technology","text":"<p>Collaborate with users who rely on assistive technologies to test your application. Real-world feedback can reveal issues that are not apparent during automated or manual testing.</p>"},{"location":"core/accessibility/testing/#5-accessibility-testing-checklist","title":"5. Accessibility Testing Checklist","text":"<p>By combining automated tools, manual testing, and user feedback, you can ensure that your React application is accessible to a diverse audience.</p>"},{"location":"core/architecture/feature-based/","title":"Feature Based","text":"<p>feature based</p>"},{"location":"core/architecture/state-management/","title":"State Management","text":"<p>state management</p>"},{"location":"core/auth/authentication-flow/","title":"Authentication Flow","text":""},{"location":"core/auth/authentication-flow/#overview","title":"Overview","text":"<p>Implementing authentication ensures secure access to protected resources in your application. In this section, we detail the process of creating a robust authentication flow.</p>"},{"location":"core/auth/authentication-flow/#steps-to-implement-authentication","title":"Steps to Implement Authentication","text":""},{"location":"core/auth/authentication-flow/#step-1-create-login-and-signup-pages","title":"Step 1: Create Login and Signup Pages","text":"<p>Create <code>Login.jsx</code> and <code>Signup.jsx</code> components inside the <code>features/auth/pages/</code> directory:</p> <pre><code>// Login.jsx\nimport React, { useState } from \"react\";\nimport api from \"../../shared/api\";\n\nconst Login = () =&gt; {\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n\n  const handleLogin = async () =&gt; {\n    try {\n      const response = await api.post(\"/auth/login\", { email, password });\n      localStorage.setItem(\"token\", response.data.token);\n      alert(\"Login successful!\");\n    } catch (error) {\n      console.error(\"Login Error:\", error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Login&lt;/h1&gt;\n      &lt;input\n        type=\"email\"\n        placeholder=\"Email\"\n        value={email}\n        onChange={(e) =&gt; setEmail(e.target.value)}\n      /&gt;\n      &lt;input\n        type=\"password\"\n        placeholder=\"Password\"\n        value={password}\n        onChange={(e) =&gt; setPassword(e.target.value)}\n      /&gt;\n      &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Login;\n</code></pre>"},{"location":"core/auth/authentication-flow/#step-2-protect-api-requests","title":"Step 2: Protect API Requests","text":"<p>Add a request interceptor in your Axios instance (<code>api.js</code>) to include the authentication token:</p> <pre><code>api.interceptors.request.use(\n  (config) =&gt; {\n    config.headers[\"Authorization\"] = `Bearer ${localStorage.getItem(\"token\")}`;\n    return config;\n  },\n  (error) =&gt; Promise.reject(error)\n);\n</code></pre>"},{"location":"core/auth/authentication-flow/#step-3-handle-token-expiry","title":"Step 3: Handle Token Expiry","text":"<p>Implement token expiration logic and prompt users to log in again if the token is invalid:</p> <pre><code>api.interceptors.response.use(\n  (response) =&gt; response,\n  (error) =&gt; {\n    if (error.response &amp;&amp; error.response.status === 401) {\n      alert(\"Session expired. Please log in again.\");\n      localStorage.removeItem(\"token\");\n      window.location.href = \"/login\";\n    }\n    return Promise.reject(error);\n  }\n);\n</code></pre>"},{"location":"core/auth/protected-routes/","title":"Protected Route","text":""},{"location":"core/auth/protected-routes/#overview","title":"Overview","text":"<p>Protected routes ensure that only authenticated users can access certain parts of the application. Here, we implement protected routes using React Router.</p>"},{"location":"core/auth/protected-routes/#steps-to-create-protected-routes","title":"Steps to Create Protected Routes","text":""},{"location":"core/auth/protected-routes/#step-1-create-a-privateroute-component","title":"Step 1: Create a PrivateRoute Component","text":"<p>Create <code>PrivateRoute.jsx</code> inside the <code>features/auth/components/</code> directory:</p> <pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\n\nconst PrivateRoute = ({ children }) =&gt; {\n  const isAuthenticated = !!localStorage.getItem(\"token\");\n\n  return isAuthenticated ? children : &lt;Navigate to=\"/login\" replace /&gt;;\n};\n\nexport default PrivateRoute;\n</code></pre>"},{"location":"core/auth/protected-routes/#step-2-wrap-protected-routes","title":"Step 2: Wrap Protected Routes","text":"<p>Wrap your protected routes with the <code>PrivateRoute</code> component in <code>App.jsx</code>:</p> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport Login from \"./features/auth/pages/Login\";\nimport Dashboard from \"./features/dashboard/pages/Dashboard\";\nimport PrivateRoute from \"./features/auth/components/PrivateRoute\";\n\nconst App = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n        &lt;Route\n          path=\"/dashboard\"\n          element={\n            &lt;PrivateRoute&gt;\n              &lt;Dashboard /&gt;\n            &lt;/PrivateRoute&gt;\n          }\n        /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"core/auth/protected-routes/#benefits-of-protected-routes","title":"Benefits of Protected Routes","text":"<ul> <li>Enhances application security.</li> <li>Ensures sensitive data is accessible only to authenticated users.</li> <li>Provides a seamless user experience.</li> </ul>"},{"location":"core/debugging/debugging-guide/","title":"\ud83d\udee0\ufe0f Debugging Guide for React Applications","text":"<p>Debugging React applications efficiently is crucial for maintaining application stability and resolving issues quickly. This guide outlines various tools and techniques for debugging React apps.</p>"},{"location":"core/debugging/debugging-guide/#1-debugging-with-browser-devtools","title":"1. Debugging with Browser DevTools","text":"<p>Modern browsers provide excellent DevTools to debug React applications. Key features include:</p>"},{"location":"core/debugging/debugging-guide/#inspecting-components","title":"Inspecting Components","text":"<ul> <li>Right-click on any element and select Inspect to view its DOM structure.</li> <li>Use the Elements tab to modify styles and view applied CSS.</li> </ul>"},{"location":"core/debugging/debugging-guide/#viewing-console-logs","title":"Viewing Console Logs","text":"<ul> <li>Use the Console tab to view logs, warnings, and errors.</li> <li>Add <code>console.log()</code> in your code to inspect variable values and component props/state.</li> </ul>"},{"location":"core/debugging/debugging-guide/#debugging-network-requests","title":"Debugging Network Requests","text":"<ul> <li>Use the Network tab to inspect API calls, request/response payloads, and status codes.</li> </ul>"},{"location":"core/debugging/debugging-guide/#2-react-developer-tools","title":"2. React Developer Tools","text":"<p>React DevTools is a browser extension specifically for debugging React apps. It provides:</p>"},{"location":"core/debugging/debugging-guide/#features","title":"Features","text":"<ul> <li>Inspect React component hierarchy.</li> <li>View and edit props and state in real time.</li> <li>Trace component renders to identify performance bottlenecks.</li> </ul>"},{"location":"core/debugging/debugging-guide/#installation","title":"Installation","text":"<p>Install React DevTools from your browser\u2019s extension store:</p> <ul> <li>Chrome Extension</li> <li>Firefox Add-on</li> </ul>"},{"location":"core/debugging/debugging-guide/#3-debugging-state-management","title":"3. Debugging State Management","text":""},{"location":"core/debugging/debugging-guide/#redux-devtools","title":"Redux DevTools","text":"<p>If you use Redux for state management, Redux DevTools is invaluable.</p>"},{"location":"core/debugging/debugging-guide/#features_1","title":"Features","text":"<ul> <li>Inspect the Redux store.</li> <li>View dispatched actions and state changes.</li> <li>Time travel to previous states.</li> </ul>"},{"location":"core/debugging/debugging-guide/#setup","title":"Setup","text":"<ol> <li>Install Redux DevTools Extension:</li> </ol> <pre><code>pnpm add redux-devtools-extension\n</code></pre> <ol> <li>Enable in your store configuration:</li> </ol> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n  enhancers: [composeWithDevTools()],\n});\n</code></pre>"},{"location":"core/debugging/debugging-guide/#4-debugging-asynchronous-code","title":"4. Debugging Asynchronous Code","text":""},{"location":"core/debugging/debugging-guide/#common-tools","title":"Common Tools","text":"<ul> <li>Use async/await for cleaner syntax and easier debugging.</li> <li>Handle promise rejections with <code>.catch()</code> to log errors.</li> </ul> <p>Debugging Fetch or Axios Requests</p> <ul> <li>Add error handling to log API call issues:</li> </ul> <pre><code>try {\n  const response = await axios.get(\"/api/data\");\n  console.log(response.data);\n} catch (error) {\n  console.error(\"Error fetching data:\", error);\n}\n</code></pre>"},{"location":"core/debugging/debugging-guide/#5-using-breakpoints","title":"5. Using Breakpoints","text":""},{"location":"core/debugging/debugging-guide/#adding-breakpoints-in-code","title":"Adding Breakpoints in Code","text":"<ul> <li>Use <code>debugger;</code> statements in your code to pause execution:</li> </ul> <pre><code>const handleClick = () =&gt; {\n  debugger;\n  console.log(\"Button clicked!\");\n};\n</code></pre>"},{"location":"core/debugging/debugging-guide/#setting-breakpoints-in-devtools","title":"Setting Breakpoints in DevTools","text":"<ul> <li>Open the Sources tab and set breakpoints directly in the code.</li> </ul>"},{"location":"core/debugging/debugging-guide/#6-common-debugging-issues-and-solutions","title":"6. Common Debugging Issues and Solutions","text":""},{"location":"core/debugging/debugging-guide/#problem-component-not-rendering","title":"Problem: Component Not Rendering","text":"<ul> <li>Check for typos in component names.</li> <li>Verify that the component is correctly imported and used.</li> </ul>"},{"location":"core/debugging/debugging-guide/#problem-state-not-updating","title":"Problem: State Not Updating","text":"<ul> <li>Ensure <code>setState</code> or the Redux action is called correctly.</li> <li>Verify immutability in state updates.</li> </ul>"},{"location":"core/debugging/debugging-guide/#problem-api-call-fails","title":"Problem: API Call Fails","text":"<ul> <li>Check the Network tab for error details.</li> <li>Verify API endpoint and request payload.</li> </ul>"},{"location":"core/debugging/debugging-guide/#7-debugging-performance","title":"7. Debugging Performance","text":""},{"location":"core/debugging/debugging-guide/#react-profiler","title":"React Profiler","text":"<p>Use the React Profiler to:</p> <ul> <li>Measure component render times.</li> <li>Identify unnecessary re-renders.</li> </ul>"},{"location":"core/debugging/debugging-guide/#installation_1","title":"Installation","text":"<ul> <li>The React Profiler is included with React DevTools.</li> </ul>"},{"location":"core/debugging/debugging-guide/#usage","title":"Usage","text":"<ol> <li>Open React DevTools.</li> <li>Navigate to the Profiler tab.</li> <li>Start recording, interact with your app, and analyze the results.</li> </ol>"},{"location":"core/debugging/debugging-guide/#8-additional-tools","title":"8. Additional Tools","text":"<ul> <li>VS Code Debugger: Debug React apps directly in VS Code.</li> <li>LogRocket: Capture logs and user sessions for deeper insights.</li> <li>Sentry: Monitor and debug errors in production.</li> </ul>"},{"location":"core/error-handling/api-error-handling/","title":"Handling API errors","text":""},{"location":"core/error-handling/api-error-handling/#overview","title":"Overview","text":"<p>API error handling ensures that network errors, server errors, or invalid responses are handled gracefully, providing a better user experience.</p>"},{"location":"core/error-handling/api-error-handling/#handling-api-errors-with-axios","title":"Handling API Errors with Axios","text":"<p>Step 1: Create an Axios Instance</p> <p>Create an <code>api.js</code> file:</p> <pre><code>import axios from \"axios\";\n\nconst api = axios.create({\n  baseURL: \"https://api.example.com\",\n  timeout: 5000,\n});\n\n// Add a request interceptor\napi.interceptors.request.use(\n  (config) =&gt; {\n    // Add custom headers or authentication tokens\n    config.headers[\"Authorization\"] = `Bearer ${localStorage.getItem(\"token\")}`;\n    return config;\n  },\n  (error) =&gt; Promise.reject(error)\n);\n\n// Add a response interceptor\napi.interceptors.response.use(\n  (response) =&gt; response,\n  (error) =&gt; {\n    if (error.response) {\n      // Server errors\n      console.error(\"Server Error:\", error.response.status);\n      alert(`Error: ${error.response.data.message || \"An error occurred.\"}`);\n    } else if (error.request) {\n      // Network errors\n      console.error(\"Network Error:\", error.message);\n      alert(\"Network error. Please check your internet connection.\");\n    } else {\n      console.error(\"Unexpected Error:\", error.message);\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default api;\n</code></pre> <p>Step 2: Use the Axios Instance</p> <p>In your API calls, use the configured Axios instance:</p> <pre><code>import api from \"./api\";\n\nconst fetchData = async () =&gt; {\n  try {\n    const response = await api.get(\"/data\");\n    console.log(\"Data:\", response.data);\n  } catch (error) {\n    console.error(\"API Error:\", error);\n  }\n};\n\nfetchData();\n</code></pre>"},{"location":"core/error-handling/api-error-handling/#best-practices-for-api-error-handling","title":"Best Practices for API Error Handling","text":"<ul> <li>Provide meaningful error messages to users.</li> <li>Retry failed requests if applicable.</li> <li>Log errors for debugging and analytics.</li> <li>Implement fallback mechanisms for critical failures.</li> </ul> <p>With these strategies, you can effectively handle both global and API-specific errors, ensuring a robust and user-friendly application.</p>"},{"location":"core/error-handling/global-error-boundaries/","title":"Global Error Boundaries","text":""},{"location":"core/error-handling/global-error-boundaries/#overview","title":"Overview","text":"<p>Global error boundaries are a way to catch JavaScript errors anywhere in the React component tree, log those errors, and display a fallback UI instead of crashing the application.</p>"},{"location":"core/error-handling/global-error-boundaries/#creating-a-global-error-boundary","title":"Creating a Global Error Boundary","text":"<p>Step 1: Create an Error Boundary Component</p> <p>Create a <code>GlobalErrorBoundary.jsx</code> file:</p> Class Component <pre><code>import React from \"react\";\n\nclass GlobalErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    static getDerivedStateFromError(error) {\n        // Update state to trigger fallback UI\n        return { hasError: true };\n    }\n\n    componentDidCatch(error, errorInfo) {\n        // Log the error details\n        console.error(\"Error occurred:\", error, errorInfo);\n    }\n\n    render() {\n        if (this.state.hasError) {\n            return &lt;h1&gt;Something went wrong. Please try again later.&lt;/h1&gt;;\n        }\n        return this.props.children;\n    }\n}\n\nexport default GlobalErrorBoundary;\n</code></pre> <p>Step 2: Wrap Your Application with the Error Boundary</p> <p>Wrap your App component with the error boundary in <code>index.js</code> or <code>App.js</code>:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport GlobalErrorBoundary from \"./GlobalErrorBoundary\";\n\nReactDOM.render(\n  &lt;GlobalErrorBoundary&gt;\n    &lt;App /&gt;\n  &lt;/GlobalErrorBoundary&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre>"},{"location":"core/error-handling/global-error-boundaries/#benefits-of-using-error-boundaries","title":"Benefits of Using Error Boundaries","text":"<ul> <li>Prevents the application from crashing due to unhandled errors.</li> <li>Provides a user-friendly fallback UI.</li> <li>Logs error details for debugging.</li> </ul>"},{"location":"core/guidelines/file-structure/","title":"File Structure Guidelines","text":"<p>A well-organized file structure is critical for the maintainability and scalability of a frontend application. This document outlines the recommended structure for modern frontend projects.</p>"},{"location":"core/guidelines/file-structure/#why-a-standardized-file-structure-matters","title":"Why a Standardized File Structure Matters","text":"<ul> <li>Scalability: Easily add new features without cluttering the codebase.</li> <li>Readability: Make it easier for team members to navigate the project.</li> <li>Reusability: Facilitate the reuse of components, utilities, and other resources.</li> <li>Maintainability: Simplify debugging and future enhancements.</li> </ul>"},{"location":"core/guidelines/file-structure/#recommended-folder-structure","title":"Recommended Folder Structure","text":"<p>Below is an example of a feature-based folder structure for a modern React application:</p> <pre><code>src/\n\u251c\u2500\u2500 assets/             # Static assets (images, fonts, etc.)\n\u251c\u2500\u2500 components/         # Reusable UI components\n\u251c\u2500\u2500 features/           # Feature-specific code\n\u2502   \u251c\u2500\u2500 feature1/       # Feature 1\n\u2502   \u2502   \u251c\u2500\u2500 components/ # Feature-specific components\n\u2502   \u2502   \u251c\u2500\u2500 hooks/      # Custom hooks for the feature\n\u2502   \u2502   \u251c\u2500\u2500 pages/      # Pages related to the feature\n\u2502   \u2502   \u251c\u2500\u2500 services/   # API calls or business logic\n\u2502   \u2502   \u2514\u2500\u2500 types.ts    # TypeScript types for the feature\n\u2502   \u2514\u2500\u2500 feature2/       # Feature 2 (similar structure)\n\u251c\u2500\u2500 hooks/              # Shared custom hooks\n\u251c\u2500\u2500 layouts/            # Layout components (e.g., Sidebar, Header)\n\u251c\u2500\u2500 routes/             # Application routes\n\u251c\u2500\u2500 services/           # Shared services (e.g., API clients)\n\u251c\u2500\u2500 store/              # Global state management (Redux, Zustand, etc.)\n\u251c\u2500\u2500 styles/             # Global styles (CSS, SCSS, or styled-components)\n\u251c\u2500\u2500 types/              # Shared TypeScript types\n\u251c\u2500\u2500 utils/              # Utility functions\n\u251c\u2500\u2500 App.tsx             # Root component\n\u251c\u2500\u2500 index.tsx           # Entry point\n\u2514\u2500\u2500 vite.config.ts      # Vite configuration file\n</code></pre>"},{"location":"core/guidelines/file-structure/#folder-descriptions","title":"Folder Descriptions","text":"<p><code>src/assets</code></p> <p>Contains static assets like images, fonts, and icons.</p> <ul> <li> <p>Example</p> <pre><code>src/assets/\n\u251c\u2500\u2500 images/\n\u2502   \u251c\u2500\u2500 logo.png\n\u2502   \u2514\u2500\u2500 banner.jpg\n\u251c\u2500\u2500 fonts/\n\u2502   \u251c\u2500\u2500 OpenSans-Regular.ttf\n\u2514\u2500\u2500 icons/\n    \u251c\u2500\u2500 home.svg\n    \u2514\u2500\u2500 search.svg\n</code></pre> </li> </ul> <p><code>src/components</code></p> <p>Holds reusable UI components that are not tied to any specific feature.</p> <ul> <li> <p>Example</p> <pre><code>src/components/\n\u251c\u2500\u2500 Button/\n\u2502   \u251c\u2500\u2500 Button.tsx\n\u2502   \u2514\u2500\u2500 Button.styles.ts\n\u251c\u2500\u2500 Modal/\n\u2502   \u251c\u2500\u2500 Modal.tsx\n\u2502   \u2514\u2500\u2500 Modal.styles.ts\n</code></pre> </li> </ul> <p><code>src/features</code></p> <p>Contains feature-specific code grouped by feature. Each feature has its own subdirectory.</p> <ul> <li> <p>Example:</p> <pre><code>src/features/feature1/\n\u251c\u2500\u2500 components/\n\u251c\u2500\u2500 hooks/\n\u251c\u2500\u2500 pages/\n\u251c\u2500\u2500 services/\n\u2514\u2500\u2500 types.ts\n</code></pre> </li> </ul> <p><code>src/hooks</code></p> <p>Shared custom hooks used across multiple features.</p> <ul> <li> <p>Example:</p> <pre><code>src/hooks/\n\u251c\u2500\u2500 useAuth.ts\n\u251c\u2500\u2500 useFetch.ts\n\u2514\u2500\u2500 useToggle.ts\n</code></pre> </li> </ul> <p><code>src/layouts</code></p> <p>Defines layout components for the application, such as headers, sidebars, and footers.</p> <ul> <li> <p>Example:</p> <pre><code>src/layouts/\n\u251c\u2500\u2500 MainLayout.tsx\n\u2514\u2500\u2500 AuthLayout.tsx\n</code></pre> </li> </ul> <p><code>src/routes</code></p> <p>Manages the routing logic for the application.</p> <ul> <li> <p>Example:</p> <pre><code>src/routes/\n\u251c\u2500\u2500 AppRoutes.tsx\n\u2514\u2500\u2500 ProtectedRoute.tsx\n</code></pre> </li> </ul> <p><code>src/services</code></p> <p>Contains shared services like API clients or utility libraries for HTTP requests.</p> <ul> <li> <p>Example:</p> <pre><code>src/services/\n\u251c\u2500\u2500 apiClient.ts\n\u2514\u2500\u2500 authService.ts\n</code></pre> </li> </ul> <p><code>src/store</code></p> <p>Manages global state, typically with Redux or another state management library.</p> <ul> <li> <p>Example:</p> <pre><code>src/store/\n\u251c\u2500\u2500 slices/\n\u2502   \u251c\u2500\u2500 userSlice.ts\n\u2502   \u2514\u2500\u2500 settingsSlice.ts\n\u2514\u2500\u2500 store.ts\n</code></pre> </li> </ul> <p><code>src/styles</code></p> <p>Includes global styles, theme definitions, and CSS/SCSS files.</p> <ul> <li> <p>Example:</p> <pre><code>src/styles/\n\u251c\u2500\u2500 globals.css\n\u2514\u2500\u2500 theme.ts\n</code></pre> </li> </ul> <p><code>src/utils</code></p> <p>Utility functions used throughout the application.</p> <ul> <li> <p>Example:</p> <pre><code>src/utils/\n\u251c\u2500\u2500 dateFormatter.ts\n\u251c\u2500\u2500 debounce.ts\n\u2514\u2500\u2500 validation.ts\n</code></pre> </li> </ul>"},{"location":"core/guidelines/file-structure/#best-practices","title":"Best Practices","text":"<ul> <li>Keep It Modular: Group related code together.</li> <li>Name Consistently: Use clear, descriptive names for folders and files.</li> <li>Avoid Deep Nesting: Keep the folder structure as flat as possible.</li> <li>Use Index Files: Export components or utilities from <code>index.ts</code> files for cleaner imports.</li> <li>Document Conventions: Include <code>README.md</code> files in larger directories to explain their purpose.</li> </ul>"},{"location":"core/guidelines/file-structure/#example-usage","title":"Example Usage","text":""},{"location":"core/guidelines/file-structure/#importing-a-component","title":"Importing a Component","text":"<p>Instead of:</p> <pre><code>import Button from \"../../components/Button/Button\";\n</code></pre> <p>Use:</p> <pre><code>import Button from \"@/components/Button\";\n</code></pre>"},{"location":"core/guidelines/file-structure/#organizing-feature-specific-components","title":"Organizing Feature-Specific Components","text":"<p>Feature-specific components should reside within the respective feature folder to maintain modularity.</p> <p>A well-organized file structure is the foundation of a scalable and maintainable frontend project. Following these guidelines will help you build a robust codebase for your team.</p>"},{"location":"core/guidelines/linting-formatting/","title":"Linting &amp; Formatting","text":"<p>Linting and formatting are essential practices for maintaining code consistency, readability, and quality. This document provides guidelines for setting up and using linting and formatting tools in a modern frontend project.</p>"},{"location":"core/guidelines/linting-formatting/#why-linting-formatting-matter","title":"Why Linting &amp; Formatting Matter","text":"<ul> <li>Code Consistency: Ensures all team members follow the same coding style.</li> <li>Error Prevention: Identifies potential issues before they become bugs.</li> <li>Improved Readability: Enhances the clarity of code for current and future developers.</li> <li>Automation: Saves time by automating code formatting and error detection.</li> </ul>"},{"location":"core/guidelines/linting-formatting/#linting-with-eslint","title":"Linting with ESLint","text":""},{"location":"core/guidelines/linting-formatting/#installation","title":"Installation","text":"<p>Install ESLint as a development dependency:</p> <pre><code>pnpm add eslint --save-dev\n</code></pre>"},{"location":"core/guidelines/linting-formatting/#configuration","title":"Configuration","text":"<ol> <li> <p>Initialize ESLint in your project:</p> <pre><code>npx eslint --init\n</code></pre> </li> <li> <p>Choose the options that suit your project (e.g., TypeScript, React).</p> </li> <li> <p>Example <code>.eslintrc.json</code> file:</p> <pre><code>{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true\n  },\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"plugin:@typescript-eslint/recommended\"\n  ],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\"react\", \"@typescript-eslint\"],\n  \"rules\": {\n    \"indent\": [\"error\", 2],\n    \"quotes\": [\"error\", \"single\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> </li> </ol>"},{"location":"core/guidelines/linting-formatting/#running-eslint","title":"Running ESLint","text":"<ul> <li> <p>Check for linting errors:</p> <pre><code>npx eslint .\n</code></pre> </li> <li> <p>Automatically fix fixable issues:</p> <pre><code>npx eslint . --fix\n</code></pre> </li> </ul>"},{"location":"core/guidelines/linting-formatting/#formatting-with-prettier","title":"Formatting with Prettier","text":""},{"location":"core/guidelines/linting-formatting/#installation_1","title":"Installation","text":"<p>Install Prettier as a development dependency:</p> <pre><code>pnpm add prettier --save-dev\n</code></pre>"},{"location":"core/guidelines/linting-formatting/#configuration_1","title":"Configuration","text":"<ol> <li> <p>Create a <code>.prettierrc</code> file:</p> <pre><code>{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 2,\n  \"printWidth\": 80\n}\n</code></pre> </li> <li> <p>Create a <code>.prettierignore</code> file to exclude certain files or directories:</p> <pre><code>node_modules\ndist\nbuild\ncoverage\n.env\n``\n</code></pre> </li> </ol>"},{"location":"core/guidelines/linting-formatting/#running-prettier","title":"Running Prettier","text":"<ul> <li> <p>Format files manually:</p> <pre><code>npx prettier --write .\n</code></pre> </li> </ul>"},{"location":"core/guidelines/linting-formatting/#integrating-eslint-and-prettier","title":"Integrating ESLint and Prettier","text":""},{"location":"core/guidelines/linting-formatting/#why-integrate","title":"Why Integrate?","text":"<p>Integrating ESLint and Prettier prevents conflicts between linting and formatting rules.</p>"},{"location":"core/guidelines/linting-formatting/#installation_2","title":"Installation","text":"<p>Install the necessary dependencies:</p> <pre><code>pnpm add eslint-config-prettier eslint-plugin-prettier --save-dev\n</code></pre>"},{"location":"core/guidelines/linting-formatting/#configuration_2","title":"Configuration","text":"<p>Update your <code>.eslintrc.json</code> to include Prettier:</p> <pre><code>{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n    \"plugin:prettier/recommended\"\n  ]\n}\n</code></pre>"},{"location":"core/guidelines/linting-formatting/#format-and-lint-together","title":"Format and Lint Together","text":"<p>Add the following scripts to your <code>package.json</code>:</p> <pre><code>\"scripts\": {\n  \"lint\": \"eslint .\",\n  \"format\": \"prettier --write .\"\n}\n</code></pre>"},{"location":"core/guidelines/linting-formatting/#ide-integration","title":"IDE Integration","text":""},{"location":"core/guidelines/linting-formatting/#vs-code-setup","title":"VS Code Setup","text":"<ol> <li> <p>Install the following extensions:</p> <ul> <li>ESLint</li> <li>Prettier</li> </ul> </li> <li> <p>Update your settings in <code>settings.json</code>:</p> <pre><code>{\n  \"editor.formatOnSave\": true,\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"eslint.format.enable\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true\n  }\n}\n</code></pre> </li> </ol>"},{"location":"core/guidelines/linting-formatting/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"core/guidelines/linting-formatting/#running-linting-formatting-in-cicd","title":"Running Linting &amp; Formatting in CI/CD","text":"<ol> <li> <p>Add a linting step to your CI/CD pipeline:</p> <pre><code>steps:\n    - name: Install dependencies\n        run: pnpm install\n\n    - name: Run ESLint\n        run: pnpm lint\n\n    - name: Run Prettier\n        run: pnpm format\n</code></pre> </li> </ol>"},{"location":"core/guidelines/linting-formatting/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Use ESLint to enforce coding standards and identify issues.</li> <li>Use Prettier for consistent code formatting.</li> <li>Integrate ESLint and Prettier to avoid rule conflicts.</li> <li>Configure your IDE and CI/CD pipeline for automated linting and formatting.</li> </ol>"},{"location":"core/guidelines/naming-conventions/","title":"Naming Conventions","text":"<p>Consistent naming conventions are critical for maintaining readable, scalable, and maintainable code. This document outlines best practices for naming variables, functions, files, and other elements in a modern frontend project.</p>"},{"location":"core/guidelines/naming-conventions/#general-guidelines","title":"General Guidelines","text":"<ul> <li>Be Descriptive: Use clear and meaningful names that describe the purpose of the element.</li> <li>Use CamelCase for JavaScript: Follow <code>camelCase</code> for variables, functions, and object properties.</li> <li>Avoid Abbreviations: Write full, meaningful names instead of cryptic abbreviations.</li> <li>Stay Consistent: Use the same naming patterns across the entire codebase.</li> <li>Prefix Booleans: Start boolean variables with <code>is</code>, <code>has</code>, or <code>should</code> (e.g., <code>isVisible</code>, <code>hasAccess</code>).</li> <li>Avoid Reserved Words: Don\u2019t use JavaScript reserved keywords as identifiers.</li> </ul>"},{"location":"core/guidelines/naming-conventions/#naming-variables","title":"Naming Variables","text":"Do <pre><code>const userName = 'John Doe';\nconst totalItems = 42;\nconst hasPermission = true;\n</code></pre> Don\u2019t <pre><code>const x = 'John Doe';\nconst t = 42;\nconst flag = true;\n</code></pre> <p>Constants</p> <ul> <li>Use <code>UPPER_SNAKE_CASE</code> for constants:</li> </ul> <pre><code>const MAX_RETRY_COUNT = 5;\nconst API_BASE_URL = \"https://api.example.com\";\n</code></pre>"},{"location":"core/guidelines/naming-conventions/#naming-functions","title":"Naming Functions","text":"<p>General Guidelines:</p> <ul> <li>Use <code>camelCase</code>.</li> <li>Start function names with verbs to indicate action.</li> </ul> <pre><code>function fetchUserData() {\n  // Fetch user data from API\n}\n\nfunction calculateTotalPrice(items) {\n  // Calculate the total price of items\n}\n</code></pre>"},{"location":"core/guidelines/naming-conventions/#naming-files-and-folders","title":"Naming Files and Folders","text":"<ul> <li> <p>Use kebab-case for file and folder names:</p> <pre><code>component-header.js\nuser-profile.js\n</code></pre> </li> <li> <p>Group related files into folders:</p> <pre><code>components/\n    header.js\n    footer.js\n</code></pre> </li> <li> <p>Use index files for central exports:</p> <pre><code>components/\n    header.js\n    footer.js\n    index.js // Central export file\n</code></pre> </li> </ul>"},{"location":"core/guidelines/naming-conventions/#naming-components-react","title":"Naming Components (React)","text":""},{"location":"core/guidelines/naming-conventions/#file-names","title":"File Names","text":"<ul> <li> <p>Use <code>PascalCase</code> for React component file names:</p> <pre><code>UserProfile.jsx\nHeader.jsx\n</code></pre> </li> </ul>"},{"location":"core/guidelines/naming-conventions/#component-names","title":"Component Names","text":"<ul> <li> <p>Use <code>PascalCase</code> for component names:</p> <pre><code>function UserProfile() {\n  return &lt;div&gt;User Profile&lt;/div&gt;;\n}\n\nexport default UserProfile;\n</code></pre> </li> </ul>"},{"location":"core/guidelines/naming-conventions/#naming-css-classes","title":"Naming CSS Classes","text":"<p>Use BEM (Block-Element-Modifier) Convention</p> <ul> <li>Block: Represents the parent component.</li> <li>Element: Represents a child element of the block.</li> <li>Modifier: Represents a variant or state of the block/element.</li> </ul> Example<pre><code>&lt;div class=\"button button--primary\"&gt;\n  &lt;span class=\"button__icon\"&gt;&lt;/span&gt;\n  Click Me\n&lt;/div&gt;\n</code></pre> <p>Explanation:</p> <ul> <li><code>button</code>: Block</li> <li><code>button__icon</code>: Element</li> <li><code>button--primary</code>: Modifier</li> </ul>"},{"location":"core/guidelines/naming-conventions/#naming-state-variables-react","title":"Naming State Variables (React)","text":"Use Descriptive Names <pre><code>const [userData, setUserData] = useState(null);\nconst [isLoading, setIsLoading] = useState(false);\n</code></pre> Avoid Generic Names <pre><code>const [data, setData] = useState(null); // Avoid\nconst [state, setState] = useState(false); // Avoid\n</code></pre>"},{"location":"core/guidelines/naming-conventions/#api-endpoints","title":"API Endpoints","text":"<ul> <li> <p>Use <code>snake_case</code> for API endpoint paths:</p> <pre><code>GET / api / users;\nPOST / api / users / create;\n</code></pre> </li> <li> <p>Avoid mixing conventions:</p> <pre><code>GET / api / getUsers; // Avoid\n</code></pre> </li> </ul>"},{"location":"core/guidelines/naming-conventions/#database-and-backend-naming","title":"Database and Backend Naming","text":"<ul> <li> <p>Use <code>snake_case</code> for database tables and columns:</p> <pre><code>CREATE TABLE user_profiles (\n  user_id INT PRIMARY KEY,\n  first_name VARCHAR(100),\n  last_name VARCHAR(100)\n);\n</code></pre> </li> </ul>"},{"location":"core/guidelines/naming-conventions/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Be consistent with naming conventions throughout the codebase.</li> <li>Prioritize readability and clarity.</li> <li>Use naming conventions that align with your project\u2019s language and frameworks.</li> </ul>"},{"location":"core/security/cors/","title":"Handling CORS (Cross-Origin Resource Sharing)","text":"<p>Cross-Origin Resource Sharing (CORS) is a security mechanism implemented by web browsers to prevent unauthorized access to resources from a different origin. This document provides guidance on understanding and properly handling CORS in web applications.</p>"},{"location":"core/security/cors/#what-is-cors","title":"What is CORS?","text":"<p>CORS is a protocol that allows a web application running on one origin (e.g., <code>https://example.com</code>) to access resources on another origin (e.g., <code>https://api.example.com</code>). Browsers enforce CORS to prevent potential cross-origin attacks, such as CSRF (Cross-Site Request Forgery).</p> Key Terms <ul> <li>Origin: A combination of scheme (protocol), host (domain), and port (e.g., <code>https://example.com:443</code>).</li> <li>Preflight Request: A request sent by the browser to check if the server permits cross-origin requests.</li> </ul>"},{"location":"core/security/cors/#common-scenarios-requiring-cors","title":"Common Scenarios Requiring CORS","text":"Quote <ul> <li>Accessing a third-party API.</li> <li>Communicating between subdomains (e.g., <code>app.example.com</code> and <code>api.example.com</code>).</li> <li>Hosting your frontend and backend on different origins.</li> </ul>"},{"location":"core/security/cors/#how-cors-works","title":"How CORS Works","text":""},{"location":"core/security/cors/#simple-requests","title":"Simple Requests","text":"<p>For simple requests (e.g., <code>GET</code> or <code>POST</code> with specific headers), the browser sends the request directly to the server.</p>"},{"location":"core/security/cors/#preflight-requests","title":"Preflight Requests","text":"<p>For complex requests (e.g., <code>PUT</code>, <code>DELETE</code>, or requests with custom headers), the browser sends a preflight <code>OPTIONS</code> request to the server to determine if the actual request is allowed.</p>"},{"location":"core/security/cors/#server-response","title":"Server Response","text":"<p>The server must respond with appropriate CORS headers, such as:</p> <pre><code>Access-Control-Allow-Origin: https://example.com\nAccess-Control-Allow-Methods: GET, POST\nAccess-Control-Allow-Headers: Content-Type\n</code></pre>"},{"location":"core/security/cors/#setting-up-cors","title":"Setting Up CORS","text":""},{"location":"core/security/cors/#configuring-cors-on-the-server","title":"Configuring CORS on the Server","text":"<p>CORS headers need to be configured on the server-side to allow cross-origin requests. Below are examples for popular backend frameworks.</p> Node.js with Express <pre><code>const cors = require(\"cors\");\nconst express = require(\"express\");\nconst app = express();\n\nconst corsOptions = {\n    origin: \"https://example.com\",\n    methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allowedHeaders: [\"Content-Type\", \"Authorization\"],\n};\n\napp.use(cors(corsOptions));\n\napp.get(\"/api\", (req, res) =&gt; {\n    res.json({ message: \"CORS is configured!\" });\n});\n\napp.listen(3000, () =&gt; console.log(\"Server running on port 3000\"));\n</code></pre> Python with Flask <pre><code>from flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app, resources={r\"/*\": {\"origins\": \"https://example.com\"}})\n\n@app.route(\"/api\")\ndef api():\n    return {\"message\": \"CORS is configured!\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> Django <p>Install and configure the django-cors-headers package:</p> <pre><code>pip install django-cors-headers\n</code></pre> <p>Add to your <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS += [\n    'corsheaders',\n]\n\nMIDDLEWARE = [\n    'corsheaders.middleware.CorsMiddleware',\n    *MIDDLEWARE,\n]\n\nCORS_ALLOWED_ORIGINS = [\n    'https://example.com',\n]\n</code></pre>"},{"location":"core/security/cors/#using-proxy-servers","title":"Using Proxy Servers","text":"<p>If you cannot modify the server, set up a proxy to handle CORS. For example, configure a proxy in a React app:</p> vite.config.js<pre><code>import { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  server: {\n    proxy: {\n      \"/api\": {\n        target: \"https://api.example.com\",\n        changeOrigin: true,\n      },\n    },\n  },\n});\n</code></pre>"},{"location":"core/security/cors/#debugging-cors-issues","title":"Debugging CORS Issues","text":""},{"location":"core/security/cors/#common-errors","title":"Common Errors","text":"<ul> <li>No 'Access-Control-Allow-Origin' header: The server did not respond with a valid CORS header.</li> <li>CORS preflight request failed: The server did not respond to the preflight <code>OPTIONS</code> request.</li> </ul>"},{"location":"core/security/cors/#tools-for-debugging","title":"Tools for Debugging","text":"<ul> <li>Use browser developer tools to inspect network requests and responses.</li> <li>Check the server logs for CORS-related errors.</li> </ul>"},{"location":"core/security/cors/#checklist","title":"Checklist","text":"<ul> <li>Verify the server includes the correct <code>Access-Control-Allow-Origin</code> header.</li> <li>Ensure preflight requests are handled correctly on the server.</li> <li>Confirm that the browser and server are communicating over HTTPS.</li> </ul>"},{"location":"core/security/cors/#security-considerations","title":"Security Considerations","text":""},{"location":"core/security/cors/#restrict-allowed-origins","title":"Restrict Allowed Origins","text":"<ul> <li> <p>Avoid using <code>*</code> as the value for <code>Access-Control-Allow-Origin</code> in production.</p> </li> <li> <p>Specify exact origins:</p> <pre><code>Access-Control-Allow-Origin: https://example.com\n</code></pre> </li> </ul>"},{"location":"core/security/cors/#validate-tokens","title":"Validate Tokens","text":"<ul> <li>Use proper authentication mechanisms (e.g., JWTs) to validate API requests.</li> </ul>"},{"location":"core/security/cors/#limit-methods-and-headers","title":"Limit Methods and Headers","text":"<ul> <li>Restrict <code>Access-Control-Allow-Methods</code> and <code>Access-Control-Allow-Headers</code> to only what is necessary.</li> </ul>"},{"location":"core/security/cors/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>Implement rate limiting to prevent abuse of your API.</li> </ul> <p>By correctly setting up and managing CORS, you can securely enable cross-origin communication while protecting your application from potential threats.</p>"},{"location":"core/security/token-management/","title":"Token Management","text":""},{"location":"core/security/token-management/#secure-token-management","title":"Secure Token Management","text":"<p>Secure token management is essential for protecting sensitive user data and maintaining the integrity of your application. This guide outlines best practices for handling tokens, such as access tokens and refresh tokens, in web applications.</p>"},{"location":"core/security/token-management/#types-of-tokens","title":"Types of Tokens","text":""},{"location":"core/security/token-management/#access-tokens","title":"Access Tokens","text":"<ul> <li>Used for authenticating API requests.</li> <li>Short-lived, usually valid for minutes or hours.</li> </ul>"},{"location":"core/security/token-management/#refresh-tokens","title":"Refresh Tokens","text":"<ul> <li>Used to obtain new access tokens without requiring the user to re-authenticate.\\</li> <li>Long-lived but should be securely stored.</li> </ul>"},{"location":"core/security/token-management/#best-practices-for-token-storage","title":"Best Practices for Token Storage","text":""},{"location":"core/security/token-management/#storing-access-tokens","title":"Storing Access Tokens","text":"<ul> <li>Store access tokens in memory for security.</li> <li>Do not store access tokens in localStorage or sessionStorage to avoid vulnerabilities such as XSS (Cross-Site Scripting).</li> </ul>"},{"location":"core/security/token-management/#storing-refresh-tokens","title":"Storing Refresh Tokens","text":"<ul> <li>Store refresh tokens securely, such as in an HTTP-only cookie.</li> <li>HTTP-only cookies cannot be accessed by JavaScript, reducing the risk of XSS attacks.</li> </ul>"},{"location":"core/security/token-management/#secure-token-transmission","title":"Secure Token Transmission","text":""},{"location":"core/security/token-management/#use-https","title":"Use HTTPS","text":"<ul> <li>Always use HTTPS to encrypt token transmission.</li> <li>This prevents attackers from intercepting tokens via MITM (Man-in-the-Middle) attacks.</li> </ul>"},{"location":"core/security/token-management/#set-secure-and-samesite-flags","title":"Set Secure and SameSite Flags","text":"<ul> <li> <p>Use the Secure and SameSite attributes for cookies:</p> <pre><code>Set-Cookie: refresh_token=abc123; HttpOnly; Secure; SameSite=Strict\n</code></pre> </li> </ul>"},{"location":"core/security/token-management/#token-expiry-and-rotation","title":"Token Expiry and Rotation","text":""},{"location":"core/security/token-management/#access-token-expiry","title":"Access Token Expiry","text":"<ul> <li>Use short expiration times for access tokens (e.g., 15 minutes).</li> <li>Promptly invalidate expired tokens on the server side.</li> </ul>"},{"location":"core/security/token-management/#refresh-token-rotation","title":"Refresh Token Rotation","text":"<ul> <li>Implement refresh token rotation to improve security.</li> <li>Each time a refresh token is used, issue a new refresh token and invalidate the old one.</li> </ul>"},{"location":"core/security/token-management/#handling-token-revocation","title":"Handling Token Revocation","text":""},{"location":"core/security/token-management/#server-side-revocation","title":"Server-Side Revocation","text":"<ul> <li>Maintain a blacklist of revoked tokens on the server.</li> <li>Check the blacklist during token validation.</li> </ul>"},{"location":"core/security/token-management/#logout-handling","title":"Logout Handling","text":"<ul> <li>Revoke tokens when the user logs out to prevent unauthorized access.</li> </ul>"},{"location":"core/security/token-management/#preventing-token-theft","title":"Preventing Token Theft","text":""},{"location":"core/security/token-management/#protect-against-csrf","title":"Protect Against CSRF","text":"<ul> <li>Use anti-CSRF tokens for requests that modify data.</li> <li>Validate the CSRF token on the server.</li> </ul>"},{"location":"core/security/token-management/#monitor-for-anomalies","title":"Monitor for Anomalies","text":"<ul> <li>Implement anomaly detection to monitor unusual token usage (e.g., multiple IPs).</li> </ul>"},{"location":"core/security/token-management/#implementing-token-handling-in-react","title":"Implementing Token Handling in React","text":""},{"location":"core/security/token-management/#axios-interceptors-for-token-refresh","title":"Axios Interceptors for Token Refresh","text":"<p>Use Axios interceptors to attach access tokens to API requests and handle token refreshing:</p> <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n  baseURL: \"https://api.example.com\",\n});\n\napiClient.interceptors.request.use(async (config) =&gt; {\n  const token = getAccessToken(); // Fetch the token from memory or context\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\n\napiClient.interceptors.response.use(\n  (response) =&gt; response,\n  async (error) =&gt; {\n    if (error.response.status === 401) {\n      const refreshToken = getRefreshToken(); // Fetch the refresh token from cookies\n      if (refreshToken) {\n        const newAccessToken = await refreshAccessToken(refreshToken);\n        setAccessToken(newAccessToken);\n        error.config.headers.Authorization = `Bearer ${newAccessToken}`;\n        return apiClient(error.config);\n      }\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default apiClient;\n</code></pre>"},{"location":"core/security/token-management/#secure-context-for-tokens","title":"Secure Context for Tokens","text":"<p>Use React Context or state management tools (e.g., Redux) to store tokens in memory.</p>"},{"location":"core/security/token-management/#monitoring-and-auditing","title":"Monitoring and Auditing","text":""},{"location":"core/security/token-management/#token-logging","title":"Token Logging","text":"<ul> <li>Log token usage to detect anomalies.</li> <li>Ensure logs do not contain sensitive information like token values.</li> </ul>"},{"location":"core/security/token-management/#regular-audits","title":"Regular Audits","text":"<ul> <li>Conduct regular security audits of your token handling mechanisms.</li> </ul> <p>By following these best practices, you can minimize the risks associated with token theft and ensure a secure user authentication flow in your React application.</p>"},{"location":"core/tech-debt/tech-debt/","title":"Managing Technical Debt","text":"<p>Technical debt is an inevitable aspect of software development. However, managing it effectively ensures the long-term stability, scalability, and maintainability of your application. This guide outlines best practices for identifying, prioritizing, and addressing technical debt.</p>"},{"location":"core/tech-debt/tech-debt/#what-is-technical-debt","title":"What is Technical Debt?","text":"<p>Technical debt refers to the shortcuts, compromises, or suboptimal decisions made during development to deliver faster results. While these shortcuts save time initially, they may lead to additional work or issues in the future.</p>"},{"location":"core/tech-debt/tech-debt/#types-of-technical-debt","title":"Types of Technical Debt","text":"<ol> <li> <p>Code Debt</p> <ul> <li>Poorly written or outdated code.</li> <li>Lack of comments or documentation.</li> <li>Code that violates best practices.</li> </ul> </li> <li> <p>Design Debt</p> <ul> <li>Overcomplicated or poorly thought-out architecture.</li> <li>Coupled modules that are hard to refactor.</li> </ul> </li> <li> <p>Testing Debt</p> <ul> <li>Lack of unit, integration, or end-to-end tests.</li> <li>Untested edge cases or critical workflows.</li> </ul> </li> <li> <p>Infrastructure Debt</p> <ul> <li>Using outdated libraries or frameworks.</li> <li>Inefficient CI/CD pipelines or deployment processes.</li> </ul> </li> </ol>"},{"location":"core/tech-debt/tech-debt/#identifying-technical-debt","title":"Identifying Technical Debt","text":""},{"location":"core/tech-debt/tech-debt/#symptoms-of-technical-debt","title":"Symptoms of Technical Debt","text":"<ul> <li>Frequent bugs or regressions.</li> <li>Slow feature delivery due to complex codebase.</li> <li>Difficulty onboarding new developers.</li> <li>Reduced application performance.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#common-sources","title":"Common Sources","text":"<ul> <li>Rushed deadlines: Compromising code quality for faster delivery.</li> <li>Lack of documentation: Making it harder to understand or modify code.</li> <li>No clear standards: Inconsistent practices across the codebase.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#prioritizing-technical-debt","title":"Prioritizing Technical Debt","text":""},{"location":"core/tech-debt/tech-debt/#criteria-for-prioritization","title":"Criteria for Prioritization","text":"<ol> <li>Severity: How much does it impact the application?</li> <li>Frequency: How often does it cause problems?</li> <li>Effort vs. Impact: Is fixing it worth the effort compared to the potential improvement?</li> </ol>"},{"location":"core/tech-debt/tech-debt/#example-prioritization-matrix","title":"Example Prioritization Matrix","text":"Impact Effort Priority High Low High High High Medium Low Low Low Low High Ignore"},{"location":"core/tech-debt/tech-debt/#strategies-to-manage-technical-debt","title":"Strategies to Manage Technical Debt","text":""},{"location":"core/tech-debt/tech-debt/#1-regular-refactoring","title":"1. Regular Refactoring","text":"<ul> <li>Allocate time in each sprint for refactoring.</li> <li>Follow the Boy Scout Rule: Leave the code cleaner than you found it.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#2-document-debt","title":"2. Document Debt","text":"<ul> <li>Maintain a tech debt log to track known issues.</li> <li>Include context, proposed solutions, and potential impact.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#3-establish-standards","title":"3. Establish Standards","text":"<ul> <li>Implement coding guidelines and enforce them with linters.</li> <li>Use consistent folder structures and naming conventions.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#4-incremental-improvements","title":"4. Incremental Improvements","text":"<ul> <li>Address tech debt alongside feature development.</li> <li>Tackle small, manageable tasks rather than large rewrites.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#tools-for-managing-technical-debt","title":"Tools for Managing Technical Debt","text":"<ol> <li> <p>Static Analysis Tools</p> <ul> <li>ESLint, Prettier: For code quality and formatting.</li> <li>SonarQube: For identifying code smells and vulnerabilities.</li> </ul> </li> <li> <p>Documentation Tools</p> <ul> <li>JSDoc, Docusaurus: For maintaining project documentation.</li> </ul> </li> <li> <p>Testing Frameworks</p> <ul> <li>Jest, Cypress: For improving test coverage and reducing testing debt.</li> </ul> </li> <li> <p>Dependency Management</p> <ul> <li>Dependabot, Renovate: For automating library and framework updates.</li> </ul> </li> </ol>"},{"location":"core/tech-debt/tech-debt/#addressing-technical-debt-in-micro-frontends","title":"Addressing Technical Debt in Micro Frontends","text":"<ul> <li>Isolate Debt: Keep debt confined to individual micro frontends to reduce its impact on the entire application.</li> <li>Versioning: Clearly version components to track and address outdated code.</li> <li>Shared Libraries: Regularly update and document shared libraries or utilities.</li> </ul>"},{"location":"core/tech-debt/tech-debt/#avoiding-future-technical-debt","title":"Avoiding Future Technical Debt","text":"<ol> <li> <p>Code Reviews</p> <ul> <li>Ensure every PR is reviewed for quality and maintainability.</li> </ul> </li> <li> <p>Comprehensive Testing</p> <ul> <li>Write tests for all critical functionalities.</li> <li>Maintain a minimum test coverage percentage.</li> </ul> </li> <li> <p>Up-to-Date Dependencies</p> <ul> <li>Regularly audit and update libraries and frameworks.</li> </ul> </li> <li> <p>Knowledge Sharing</p> <ul> <li>Conduct team-wide knowledge-sharing sessions to avoid siloed expertise.</li> </ul> </li> </ol>"},{"location":"core/tech-debt/tech-debt/#conclusion","title":"Conclusion","text":"<p>While it's impossible to eliminate technical debt entirely, proactive management can mitigate its impact and ensure your project remains sustainable. Treat tech debt as an ongoing responsibility rather than a one-time task.</p>"},{"location":"core/testing/component-testing/","title":"Component Testing","text":"<p>Component testing guidelines.</p>"},{"location":"core/testing/e2e-testing/","title":"e2e Testing","text":"<p>End-to-end testing strategies.</p>"},{"location":"core/testing/unit-testing/","title":"Unit Testing","text":"<p>Unit testing with Jest.</p>"},{"location":"deployment/ci-cd/","title":"\ud83d\ude80 CI/CD Pipeline Setup","text":"<p>Continuous Integration and Continuous Deployment (CI/CD) pipelines automate building, testing, and deploying applications. This guide explains how to set up a CI/CD pipeline for a modern frontend project.</p>"},{"location":"deployment/ci-cd/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Git repository hosted on GitHub, GitLab, or another platform.</li> <li>Basic understanding of Git workflows.</li> <li>Access to a CI/CD tool like GitHub Actions, GitLab CI/CD, or CircleCI.</li> </ul>"},{"location":"deployment/ci-cd/#github-actions-example","title":"GitHub Actions Example","text":""},{"location":"deployment/ci-cd/#step-1-create-a-github-directory","title":"Step 1: Create a <code>.github</code> Directory","text":"<p>Create a <code>.github/workflows</code> directory in your project root to store workflow files.</p>"},{"location":"deployment/ci-cd/#step-2-add-a-workflow-file","title":"Step 2: Add a Workflow File","text":"<p>Create a new file named <code>ci-cd.yml</code> in the <code>.github/workflows</code> directory:</p> <pre><code>name: CI/CD Pipeline\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v3\n\n      - name: Install Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16\n\n      - name: Install Dependencies\n        run: pnpm install\n\n      - name: Run Tests\n        run: pnpm test\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: 16\n\n      - name: Build Application\n        run: pnpm build\n\n      - name: Deploy to Vercel\n        uses: amondnet/vercel-action@v20\n        with:\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\n          vercel-args: \"--prod\"\n          working-directory: \"./\"\n</code></pre>"},{"location":"deployment/ci-cd/#gitlab-cicd-example","title":"GitLab CI/CD Example","text":""},{"location":"deployment/ci-cd/#step-1-add-gitlab-ciyml","title":"Step 1: Add <code>.gitlab-ci.yml</code>","text":"<p>Create a <code>.gitlab-ci.yml</code> file in the root of your repository:</p> <pre><code>stages:\n  - install\n  - test\n  - build\n  - deploy\n\nvariables:\n  NODE_ENV: production\n\ncache:\n  paths:\n    - node_modules/\n\ninstall:\n  stage: install\n  script:\n    - pnpm install\n\ntest:\n  stage: test\n  script:\n    - pnpm test\n\nbuild:\n  stage: build\n  script:\n    - pnpm build\n\ndeploy:\n  stage: deploy\n  script:\n    - npx vercel deploy --prod --token=$VERCEL_TOKEN\n  only:\n    - main\n</code></pre>"},{"location":"deployment/ci-cd/#circleci-example","title":"CircleCI Example","text":""},{"location":"deployment/ci-cd/#step-1-add-circleciconfigyml","title":"Step 1: Add <code>.circleci/config.yml</code>","text":"<p>Create a <code>.circleci/config.yml</code> file in the root of your repository:</p> <pre><code>version: 2.1\n\njobs:\n  install:\n    docker:\n      - image: circleci/node:16\n    steps:\n      - checkout\n      - run: pnpm install\n\n  test:\n    docker:\n      - image: circleci/node:16\n    steps:\n      - checkout\n      - run: pnpm test\n\n  build:\n    docker:\n      - image: circleci/node:16\n    steps:\n      - checkout\n      - run: pnpm build\n\n  deploy:\n    docker:\n      - image: circleci/node:16\n    steps:\n      - checkout\n      - run: npx vercel deploy --prod --token=$VERCEL_TOKEN\n\nworkflows:\n  version: 2\n  ci_cd:\n    jobs:\n      - install\n      - test:\n          requires:\n            - install\n      - build:\n          requires:\n            - test\n      - deploy:\n          requires:\n            - build\n</code></pre>"},{"location":"deployment/ci-cd/#key-points","title":"Key Points","text":"<ul> <li>Replace <code>pnpm</code> commands with your project\u2019s package manager commands if different.</li> <li>Store sensitive data like tokens in environment variables or secrets (e.g., <code>VERCEL_TOKEN</code>).</li> <li>Use branch protection rules to enforce CI/CD workflows.</li> </ul> <p>Now your CI/CD pipeline is ready! Every time you push or merge to the main branch, your application will be automatically built, tested, and deployed.</p>"},{"location":"deployment/docker/","title":"Docker","text":"<p>docker</p>"},{"location":"deployment/environment-variables/","title":"Environment Variables","text":"<p>Environment variables store configuration settings that may differ between environments (e.g., development, testing, production). Managing these variables properly ensures a secure and flexible application.</p>"},{"location":"deployment/environment-variables/#why-use-environment-variables","title":"Why Use Environment Variables?","text":"<ul> <li>Security: Keep sensitive information like API keys out of your codebase.</li> <li>Flexibility: Configure settings for different environments without modifying code.</li> <li>Portability: Share configuration with other team members easily.</li> </ul>"},{"location":"deployment/environment-variables/#creating-environment-variables","title":"Creating Environment Variables","text":""},{"location":"deployment/environment-variables/#step-1-add-a-env-file","title":"Step 1: Add a .env File","text":"<p>Create a <code>.env</code> file in your project root. This file will store your environment variables.</p> Example .env file<pre><code>REACT_APP_API_URL=https://api.example.com\nREACT_APP_API_KEY=your_api_key_here\nNODE_ENV=development\n</code></pre>"},{"location":"deployment/environment-variables/#step-2-add-env-to-gitignore","title":"Step 2: Add <code>.env</code> to <code>.gitignore</code>","text":"<p>To prevent sensitive data from being committed to version control, add <code>.env</code> to your <code>.gitignore</code> file:</p> <pre><code>.env\n</code></pre>"},{"location":"deployment/environment-variables/#accessing-environment-variables","title":"Accessing Environment Variables","text":""},{"location":"deployment/environment-variables/#react-applications","title":"React Applications","text":"<p>Environment variables in React must start with <code>REACT_APP_</code> to be accessible within the codebase.</p> <pre><code>const apiUrl = process.env.REACT_APP_API_URL;\nconsole.log(`API URL: ${apiUrl}`);\n</code></pre>"},{"location":"deployment/environment-variables/#nodejs-applications","title":"Node.js Applications","text":"<p>In Node.js, you can access environment variables directly using <code>process.env</code>.</p> <pre><code>const apiKey = process.env.API_KEY;\nconsole.log(`API Key: ${apiKey}`);\n</code></pre>"},{"location":"deployment/environment-variables/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Prefix Variables for Clarity</p> <p>Use prefixes like <code>REACT_APP_</code> or <code>API_</code> to categorize variables logically.</p> </li> <li> <p>Use a Library for Type Safety</p> <p>Libraries like dotenv or env-cmd help load and manage environment variables safely.</p> <pre><code>npm install dotenv\n</code></pre> Example usage<pre><code>require(\"dotenv\").config();\nconst dbHost = process.env.DB_HOST;\n</code></pre> </li> <li> <p>Set Defaults</p> <p>Provide fallback values in case environment variables are missing:</p> <pre><code>const port = process.env.PORT || 3000;\n</code></pre> </li> <li> <p>Secure Sensitive Information</p> <p>Store sensitive variables like API keys in a secure environment, such as cloud provider secrets (e.g., AWS Secrets Manager, Azure Key Vault).</p> </li> </ol>"},{"location":"deployment/environment-variables/#environment-variable-management-tools","title":"Environment Variable Management Tools","text":""},{"location":"deployment/environment-variables/#1-dotenv","title":"1. dotenv","text":"<ul> <li>Loads variables from a <code>.env</code> file into <code>process.env</code>.</li> <li>Suitable for local development.</li> </ul>"},{"location":"deployment/environment-variables/#2-env-cmd","title":"2. env-cmd","text":"<ul> <li>Handles multiple <code>.env</code> files for different environments.</li> </ul>"},{"location":"deployment/environment-variables/#3-direnv","title":"3. direnv","text":"<ul> <li>Manages per-directory environment variables.</li> </ul>"},{"location":"deployment/environment-variables/#4-cloud-based-solutions","title":"4. Cloud-Based Solutions","text":"<ul> <li>AWS Secrets Manager, Azure Key Vault, or HashiCorp Vault for production.</li> </ul>"},{"location":"deployment/environment-variables/#deployment-specific-configuration","title":"Deployment-Specific Configuration","text":""},{"location":"deployment/environment-variables/#vercel","title":"Vercel","text":"<p>In the Vercel dashboard, go to the project settings and add environment variables under the \"Environment Variables\" section.</p>"},{"location":"deployment/environment-variables/#netlify","title":"Netlify","text":"<p>In the Netlify dashboard, go to \"Site Settings\" &gt; \"Build &amp; Deploy\" &gt; \"Environment\" and add variables there.</p>"},{"location":"deployment/environment-variables/#docker","title":"Docker","text":"<p>Pass environment variables using the <code>-e</code> flag:</p> <pre><code>docker run -e API_URL=https://api.example.com my-app\n</code></pre> <p>With proper management of environment variables, you can enhance security, flexibility, and portability in your applications.</p>"},{"location":"deployment/micro-frontend-deployment/","title":"Micro Frontend","text":"<p>mf deploymen</p>"},{"location":"deployment/netlify/","title":"Netlify","text":"<p>netlify</p>"},{"location":"deployment/vercel/","title":"Vercel","text":"<p>vercel</p>"},{"location":"deployment/solved/intro/","title":"Intro","text":"<p>why after deploying my react app and if i reloading my app with /pages or with routes it breaks but if i click in link and goes to /pages it doesn't break. i have build my app with react, vite and pnpm. how to solve this.</p> <p>When you click on a link to navigate to a route (e.g., /pages), everything works fine because the React Router handles the navigation within the single-page application (SPA). However, when you refresh the page or directly navigate to a route like /pages it breaks.</p> <p>I understand you're looking for a simpler solution. Let's break it down into the most basic steps to make your React app (built with Vite and pnpm) work after deploying, specifically with routes like /pages working even when refreshing or directly accessing them.</p> <p>The Issue</p> <p>Works when clicking links: React Router handles routing client-side, and everything works fine. Breaks when refreshing or directly accessing routes: This happens because the server doesn't know how to handle routes that don't map to static files, so it returns a 404 error.</p> <p>YOUTUBE</p>"},{"location":"deployment/solved/refresh-reloading-react/","title":"Solved","text":""},{"location":"deployment/solved/refresh-reloading-react/#locally-deployed-app-crashed-after-reloading-refreshing","title":"LOCALLY DEPLOYED APP CRASHED After <code>reloading</code> &amp; <code>refreshing</code>","text":"<pre><code>COPY --from=build /app/&lt;vite_outputdir&gt; /usr/share/nginx/html\n</code></pre> <p>to</p> <pre><code>COPY --from=build /app/dist/client /usr/share/nginx/html\n</code></pre> <p>Build and Run Container</p> <pre><code>docker build -t my-react-app .\ndocker run -p 3000:80 my-react-app\n</code></pre> <pre><code>FROM nginx:alpine\n\n# Copy the build folder\nCOPY --from=build /app/dist/client /usr/share/nginx/html\n\n# Copy custom nginx config\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre>"},{"location":"deployment/solved/refresh-reloading-react/#ifconfig-command-not-found-closed","title":"ifconfig command not found [closed]","text":"<p>ifconfig exists in the net-tools package which may not be installed by default;</p> <pre><code>sudo yum install net-tools\n</code></pre> <p>When the package is installed, it will exist as <code>/sbin/ifconfig</code>.</p>"},{"location":"deployment/solved/refresh-reloading-react/#single-page-application-spa-routing-with-nginx","title":"Single Page Application (SPA) Routing with Nginx","text":"<p>The solution you're implementing is often referred to as \"Single Page Application (SPA) Routing with Nginx\" or \"React SPA Deployment with Nginx\".</p> Specific Names for the Concept: <ol> <li> <p>SPA (Single Page Application) Fallback Routing with Nginx:</p> <ul> <li>This is the general practice of using Nginx as a reverse proxy server to handle requests and route them to the index.html of a React (or any other SPA) application. Nginx serves the static files but ensures that all non-root URL paths are directed to the <code>index.html</code> file, so the client-side JavaScript (React Router) can handle the routing.</li> </ul> </li> <li> <p>React Deployment on Nginx:</p> <ul> <li>Specifically for React apps, this would refer to using Nginx as the web server to serve the built React application (<code>index.html</code>, JavaScript bundles, CSS, etc.) and make sure routing is handled correctly even when users refresh or directly access sub-routes.</li> </ul> </li> <li> <p>Client-Side Routing with Nginx Configuration:</p> <ul> <li>A more precise way to describe this would be setting up a client-side routing mechanism (React Router, for example) while ensuring that Nginx handles fallback routes by redirecting all requests to the <code>index.html</code> file.</li> </ul> </li> </ol> <p>Why It's Needed:</p> <p>In a React app (or any other SPA), routing is handled by JavaScript on the client side. When the user refreshes the page or enters a URL directly, the server might try to serve a non-existent file for that path. This happens because the server does not understand client-side routes, so you need a web server (like Nginx) to serve the <code>index.html</code> file for all non-root paths, allowing React Router to take over the routing once the page is loaded.</p> Key Components: <ul> <li>React Router: The library that enables client-side routing in your React app.</li> <li>Nginx: A web server that serves static files and acts as a reverse proxy for handling SPA routing.</li> </ul> <p>By combining React, React Router, and Nginx with this configuration, you're ensuring that the app works smoothly even when users refresh the page or try to access different routes directly via the browser.</p>"},{"location":"deployment/solved/refresh-reloading-react/#solution-1","title":"Solution 1:","text":"ICTCmy custom <p>In the root of your directory, create <code>nginx.conf</code> file.</p> nginx_default.conf<pre><code>server {\n    listen 80;\n    root /usr/share/nginx/html;\n    index index.html;\n\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n}\n</code></pre> Dockerfile<pre><code># pull official base image\n#FROM node as build-step\nFROM node:alpine as build\n\n# Increase memory limit for npm install and npm run\nENV NODE_OPTIONS=--max_old_space_size=4096\n\n# set working directory\nWORKDIR /app\n\n\n# add `/app/node_modules/.bin` to $PATH\n#ENV PATH /app/node_modules/.bin:$PATH\n\n# install app dependencies\nCOPY package.json .\nCOPY package-lock.json .\n#RUN npm --version\n\n#RUN npm install --legacy-peer-deps\nRUN npm install react-scripts --legacy-peer-deps\n# RUN npm install -g increase-memory-limit\n# add app\n\nCOPY . .\n\n##CMD [\"npm\",\"start\"]\n\n#RUN npm run product\n\n# production environment\n#FROM nginx\n#COPY --from=build-step /app/build /usr/share/nginx/html\n##EXPOSE 3000\n#CMD [\"nginx\", \"-g\", \"daemon off;\"]\n#product end\n\n# start app\n#RUN npm run start\n\n#New Production Build Environment\n\n# RUN  set NODE_OPTIONS=--max-old-space-size=16384\n# RUN increase-memory-limit\n\n#RUN npm install\n#COPY . ./\n\n\n\n##BLock Start\nRUN npm run dockerbuild\n\nFROM nginx:1.23.1-alpine as production\nENV NODE_ENV production\nWORKDIR /usr/share/nginx/html\nRUN rm -rf ./*\nCOPY --from=build /app/build .\nCOPY ./nginx_default.conf /etc/nginx/conf.d/default.conf\nEXPOSE 80\n# Start nginx\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre> builderdocker.sh<pre><code>if [ -z \"$1\" ]\n    then\n        echo \"***********************************************\"\n        echo \"\"\n        echo \"Version must be specified e.g. sh build.sh 1.0.0.0\"\n        echo \"\"\n        echo \"***********************************************\"\n        exit\nfi\n\ndocker build . -f Dockerfile -t cqnovalweb/crmapp:$1\n</code></pre> nginx.conf<pre><code>server {\n    listen 80;\n    server_name localhost;\n\n    # Define the root directory where static files are located\n    root /usr/share/nginx/html;\n    index index.html;\n\n    # Serve index.html for all routes\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n\n    # Optionally, configure caching for static files (assets like JS, CSS)\n    location ~* \\.(?:css|js|jpg|jpeg|png|gif|ico|svg|webp)$ {\n        expires 30d;\n        add_header Cache-Control \"public, immutable, max-age=31536000\";\n    }\n\n    # Handle 404 errors (optional)\n    error_page 404 /404.html;\n    location = /404.html {\n        root /usr/share/nginx/html;\n    }\n}\n</code></pre> <pre><code># Step 1: Build the React app using pnpm and Vite\nFROM node:18 AS build\n\n# Set the working directory inside the container\nWORKDIR /app\n\n# Install pnpm globally\nRUN npm install -g pnpm\n\n# Copy package.json and pnpm-lock.yaml to install dependencies\nCOPY package.json pnpm-lock.yaml ./\n\n# Install dependencies using pnpm\nRUN pnpm install\n\n# Copy the source code to the container\nCOPY . .\n\n# Build the React app with Vite\nRUN pnpm run build\n\n# Step 2: Serve the React app using Nginx\nFROM nginx:alpine\n\n# Copy the build folder from the previous step to Nginx's html directory\nCOPY --from=build /app/dist/client /usr/share/nginx/html\n\n# Copy custom nginx config\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\n\n\n# Expose the port that Nginx is running on\nEXPOSE 80\n\n# Start the Nginx server\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre>"},{"location":"deployment/solved/refresh-reloading-react/#which-is-the-best-method","title":"Which is the best method ?","text":"Conclusion: Which is the Best Method? <ul> <li> <p>For production environments, especially if you need to handle high traffic, require fine-grained control over routing, static asset delivery, caching, or reverse proxying, using Nginx with a custom nginx.conf is generally the best choice. It\u2019s the industry standard for hosting static sites and SPAs and provides the best performance, scalability, and flexibility.</p> </li> <li> <p>If you're looking for simplicity and a full-stack JavaScript solution, using an Express server might be ideal, particularly if your app has backend needs or if you want to consolidate everything in a single codebase.</p> </li> <li> <p>For development purposes, Vite's built-in server is fantastic due to its speed and simplicity, but it should only be used in local development, not for production.</p> </li> <li> <p>For zero-config deployment with automatic scaling, SSL, and edge caching, CDN and static file hosting services (e.g., Netlify, Vercel) are a great choice. They are best suited for simple applications that don't need complex backend integratio</p> </li> </ul> <p>If you're aiming for best practices and long-term scalability, the Nginx approach with proper fallback routing is the most robust solution for production. If you're looking for simplicity and a Node.js ecosystem, Express could be a great alternative.</p>"},{"location":"deployment/solved/refresh-reloading-react/#for-shared-hosting","title":"For Shared Hosting","text":"Login to Your Shared Hosting Control Panel (cPanel) <p>Most shared hosting services use cPanel for managing web hosting accounts. Here's how you can access it:</p> <ol> <li>Log in to your hosting account.</li> <li>Go to the <code>cPanel</code> or <code>File Manager</code>.</li> </ol> Configure<code>.htaccess</code> for Client-Side Routing (Optional but Recommended) <p>React apps, particularly Single Page Applications (SPAs), rely on client-side routing (using React Router, for example). When users refresh the page or navigate to a specific route, the server needs to always serve the <code>index.html</code> file.</p> <p>Shared hosting servers often expect the URL path to correspond to actual files or directories. However, if you're using client-side routing in React, you\u2019ll need to configure the server to serve the <code>index.html</code> file for all routes. This is done by adding a <code>.htaccess</code> file.</p> <ol> <li>In the root directory (usually <code>public_html</code>), create a <code>.htaccess</code> file (if one does not already exist).</li> <li>Add the following configuration to the <code>.htaccess</code> file to ensure proper client-side routing:</li> </ol> <pre><code># Redirect all requests to the index.html file for React Router\nRewriteEngine On\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule ^ index.html [QSA,L]\n</code></pre> <p>This configuration ensures that all requests (other than those for actual files or directories) are redirected to <code>index.html</code>, allowing React Router to handle the routing.</p> Quick Summary of Key Steps: <ol> <li>Build the React app: <code>npm run build</code> (or <code>vite build</code>).</li> <li>Upload the build files: Use FTP or cPanel File Manager to upload the contents of the <code>build</code> or <code>dist</code> folder to the <code>public_html</code> folder.</li> <li>Configure <code>.htaccess</code>: To ensure client-side routing works, add the necessary rewrite rules.</li> <li>Test: Verify your app works on the shared hosting environment by checking the domain and testing routing.</li> </ol> <p>Create <code>.htaccess</code> in the root folder where your builf file is, means in the <code>index.html</code>.</p> .htaccess<pre><code># Redirect all requests to the index.html file for React Router\nRewriteEngine On\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule ^ index.html [QSA,L]\n</code></pre> <ul> <li>How to Deploy React App to Shared Hosting (CPanel) | React Website Hosting: youtube</li> <li>ReactJs Tutorial | How to Deploy A React App To A Shared Hosting (CPanel) in Less Than 4 Mins: youtube</li> </ul>"},{"location":"deployment/solved/refreshing-issue/","title":"Refreshing Issue","text":"this solution fixed the problem: <ol> <li>Create a netlify.toml in the project's root directory.</li> <li>Add the following code in the netlify.toml file:</li> </ol> <pre><code>[[redirects]]\n    from = \"/*\"\n    to = \"/\"\n    status = 200\n</code></pre> <ol> <li>Run the netlify deploy command in your terminal.</li> </ol>"},{"location":"deployment/solved/refreshing-issue/#redirects-and-rewrites","title":"Redirects and rewrites","text":"<p>You can configure redirect and rewrite rules for your Netlify site in two ways:</p> <ul> <li>Save a plain text file called <code>_redirects</code> without a file extension to the publish directory of your site. You can find _redirects file syntax details below.</li> <li>Add one or more <code>redirects</code> tables to your Netlify configuration file. This method allows for more structured configuration and additional capabilities, as described in the Netlify configuration file syntax section below.</li> </ul> <p>Netlify processes and serializes your redirect rules across the <code>_redirects</code> and <code>netlify.toml</code> files. If the size of this output is too large, the deploy might fail.</p> <p>If you need to set up 10,000 redirects or more, we recommend using wildcards or placeholders as much as possible. For a more complex redirect setup, Edge Functions can be a better option.</p>"},{"location":"deployment/solved/refreshing-issue/#reference","title":"Reference","text":"<ul> <li> <p>Netlify renders 404 on page refresh (using React and react-router: stackoverflow)</p> </li> <li> <p>404 error when i refresh/reload page everysingle page other than landing page. React app with react-router-dom: netlify forum</p> </li> <li> <p>Redirects and rewrites: docs.netlify.com</p> </li> </ul>"},{"location":"micro-frontends/best-approach/","title":"Best Approach","text":"<p>As someone new to Micro Frontends, the best approach for you will depend on your team size, project structure, and deployment preferences. Here's a detailed breakdown of the three strategies and which one is easiest to start with:</p>"},{"location":"micro-frontends/best-approach/#1-monorepo-easiest-to-start","title":"\u2705 1. Monorepo (Easiest to Start)","text":"<p>Monorepo means keeping all your micro frontends in a single repository. This is the easiest approach for small teams or when you're just starting with micro frontends.</p> <p>\u2705 Why Monorepo is Easiest:</p> <ul> <li>Single Codebase: Everything is in one Git repository.</li> <li>Easy to manage shared code: You don\u2019t need a package manager to sync versions across micro frontends.</li> <li>Fast setup: No need for complex CI/CD pipelines for each micro frontend.</li> </ul> \ud83d\ude80 Example Structure<pre><code>modern-frontend/\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 app1/\n\u2502   \u251c\u2500\u2500 app2/\n\u2502   \u2514\u2500\u2500 shared-lib/\n\u2514\u2500\u2500 package.json\n</code></pre> \ud83d\udea7 When to Use <ul> <li>Small projects.</li> <li>Single team managing multiple micro frontends.</li> <li>You need fast collaboration.</li> </ul> <p>Pros:</p> <ul> <li>\u2705 Easy to set up and manage.</li> <li>\u2705 Shared libraries can be updated without publishing separate packages.</li> <li>\u2705 Easier CI/CD pipeline (one pipeline for the whole project).</li> </ul> <p>Cons:</p> <ul> <li>\u274c Doesn\u2019t scale well for large teams or multiple independent deployments.</li> <li>\u274c Slower build times as the repo grows.</li> </ul> \ud83d\udee0 Tools to Use for Monorepo <ul> <li> <p>Nx (recommended for React-based projects):</p> <pre><code>pnpm add -g nx\nnx create-nx-workspace modern-frontend\n</code></pre> </li> <li> <p>Turborepo: Another fast build system for monorepos.</p> </li> </ul>"},{"location":"micro-frontends/best-approach/#2-independent-repos-more-advanced","title":"\ud83d\uddc2\ufe0f 2. Independent Repos (More Advanced)","text":"<p>In this setup, each micro frontend has its own Git repository, its own CI/CD pipeline, and is deployed independently.</p> \ud83d\ude80 Example Structure<pre><code>GitHub/\n\u251c\u2500\u2500 app1/\n\u251c\u2500\u2500 app2/\n\u2514\u2500\u2500 shared-lib/\n</code></pre> \ud83d\udea7 When to Use <ul> <li>Large projects with multiple teams.</li> <li>Each team works on a different micro frontend.</li> <li>You need independent deployment.</li> </ul> <p>Pros:</p> <ul> <li>\u2705 Each micro frontend can be developed, tested, and deployed independently.</li> <li>\u2705 Teams can work in parallel without affecting each other.</li> <li>\u2705 Scales well for large organizations.</li> </ul> <p>Cons:</p> <ul> <li>\u274c Harder to manage shared code (you need to publish shared libraries).</li> <li>\u274c Complex CI/CD pipelines.</li> <li>\u274c Requires more DevOps setup and versioning.</li> </ul>"},{"location":"micro-frontends/best-approach/#3-versioning-and-caching-intermediate","title":"\ud83d\udd04 3. Versioning and Caching (Intermediate)","text":"<p>This is a more advanced approach where you use versioning to manage shared libraries between micro frontends and cache static assets to reduce loading times.</p> <p>\u2705 Why Use Versioning &amp; Caching:</p> <ul> <li>Prevents breaking changes in shared code.</li> <li>Improves performance by caching micro frontend assets.</li> </ul> \ud83d\udea7 When to Use <ul> <li>When your micro frontends are already live and you need backward compatibility.</li> <li>When you want better performance for loading micro frontends.</li> </ul> <p>Pros:</p> <ul> <li>\u2705 Prevents breaking changes with versioned APIs.</li> <li>\u2705 Improved performance with caching mechanisms.</li> </ul> <p>Cons:</p> <ul> <li>\u274c Requires more complex setups (like Webpack Module Federation or Vite).</li> <li>\u274c Harder for beginners to manage version conflicts.</li> </ul>"},{"location":"micro-frontends/best-approach/#recommendation-for-you-monorepo","title":"\ud83c\udfc6 Recommendation for You: Monorepo","text":"<p>Since you're new to Micro Frontends, start with the Monorepo approach because:</p> <ul> <li>It\u2019s easier to set up and manage.</li> <li>You can learn the concepts of micro frontends without worrying about complex deployment pipelines.</li> <li>You can migrate to Independent Repos later as your project grows.</li> </ul>"},{"location":"micro-frontends/best-approach/#steps-to-set-up-monorepo-for-micro-frontends","title":"\ud83d\ude80 Steps to Set Up Monorepo for Micro Frontends:","text":"<p>1\ufe0f\u20e3 Install Nx (Monorepo Tool):</p> <pre><code>pnpm add -g nx\n</code></pre> <p>2\ufe0f\u20e3 Create a Workspace:</p> <pre><code>nx create-nx-workspace modern-frontend\n</code></pre> <p>3\ufe0f\u20e3 Add Micro Frontends (Apps):</p> <pre><code>nx generate @nx/react:app app1\nnx generate @nx/react:app app2\n</code></pre> <p>4\ufe0f\u20e3 Set Up Module Federation for Micro Frontends:</p> <ul> <li>Use Webpack Module Federation to share components and state between micro frontends.</li> </ul>"},{"location":"micro-frontends/best-approach/#key-concepts-to-learn-next","title":"\ud83e\uddd1\u200d\ud83d\udcbb Key Concepts to Learn Next:","text":"<ul> <li>Module Federation (for sharing code between micro frontends).</li> <li>Nx or Turborepo (for managing Monorepos).</li> <li>CI/CD Pipelines for deploying micro frontends.</li> </ul>"},{"location":"micro-frontends/deployment-strategies/","title":"Micro Frontends: Deployment Strategies","text":"<p>Deploying Micro Frontends can be challenging due to their independent nature. Below are some deployment strategies:</p>"},{"location":"micro-frontends/deployment-strategies/#deployment-options","title":"Deployment Options","text":"<ul> <li>Monorepo</li> <li>Independent Repos</li> <li>Versioning and Caching</li> </ul> <pre><code>## Deployment Options\n\n1. **Monorepo**\n   - All Micro Frontends are in a single repository, making it easier to manage dependencies and code sharing.\n\n2. **Independent Repositories**\n   - Each Micro Frontend is in its own repository, allowing for independent versioning and deployment.\n\n3. **Versioning and Caching**\n   - Use semantic versioning and cache-busting strategies to ensure users always get the latest updates.\n</code></pre>"},{"location":"micro-frontends/deployment-strategies/#example-cicd-pipeline","title":"Example CI/CD Pipeline","text":"<pre><code>name: Deploy Micro Frontends\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Install dependencies\n        run: pnpm install\n\n      - name: Build application\n        run: pnpm build\n\n      - name: Deploy to S3\n        run: aws s3 sync ./dist s3://my-microfrontend-bucket\n</code></pre>"},{"location":"micro-frontends/detailed-guide/","title":"Detailed Guide","text":"<p>Let's create a detailed guide on setting up a Monorepo with Module Federation for Micro Frontends using Nx. I'll break it down into simple steps, covering:</p> <ul> <li>Project Setup with Nx</li> <li>Creating Micro Frontend Apps</li> <li>Setting Up Module Federation</li> <li>Sharing Components &amp; State</li> <li>Running &amp; Deploying the Micro Frontends</li> </ul> <p>Let me know if you'd like this guide in canvas mode for easy editing, or if you'd prefer me to share it here directly. \ud83d\ude0a</p>"},{"location":"micro-frontends/detailed-guide/#short-guide","title":"Short Guide","text":"<p>Yes, when you create a host app and remote apps using Nx, they are automatically generated inside the <code>apps/</code> folder.</p> Note <p>when we create or generate using <code>npx create-nx-workspace@latest &lt;Workspace name&gt;</code>, then it will gives us list of action to perform. and if we select mono repo with js. it only then create <code>apps/</code> directory or folder. otherwise it doesn't create <code>apps</code> folder.</p> <p>Here's how the file structure looks after running the commands:</p>"},{"location":"micro-frontends/detailed-guide/#folder-structure-after-generating-host-and-remote-apps","title":"\u2705 Folder Structure After Generating Host and Remote Apps","text":"<pre><code>my-mfe-workspace/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 my-host/       \ud83d\udc48 Host App (Main Shell)\n\u2502   \u251c\u2500\u2500 my-remote1/    \ud83d\udc48 Remote App 1\n\u2502   \u2514\u2500\u2500 my-remote2/    \ud83d\udc48 Remote App 2\n\u251c\u2500\u2500 libs/              \ud83d\udc48 (Optional for shared code)\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 nx.json\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 tsconfig.base.json\n</code></pre>"},{"location":"micro-frontends/detailed-guide/#whats-inside-each-app-folder","title":"\ud83d\udcc1 What\u2019s Inside Each App Folder?","text":"Folder Description <code>my-host</code> The host app (main entry point). <code>my-remote1</code> The first remote app. <code>my-remote2</code> The second remote app."},{"location":"micro-frontends/detailed-guide/#how-to-check-the-installed-apps","title":"\u2705 How to Check the Installed Apps","text":"<p>To verify that the apps are installed, run:</p> <pre><code>nx show projects\n</code></pre> You will see an output like this:<pre><code>my-host\nmy-remote1\nmy-remote2\n</code></pre>"},{"location":"micro-frontends/detailed-guide/#ready-to-run-the-apps","title":"\ud83d\ude80 Ready to Run the Apps?","text":"<p>Now that the apps are created, you can serve them by running:</p> <pre><code>nx serve my-host\n</code></pre> <p>This will automatically start:</p> <ul> <li>The host app at <code>http://localhost:4200</code>.</li> <li>The remote apps (<code>my-remote1</code> and <code>my-remote2</code>) on dynamic ports.</li> </ul>"},{"location":"micro-frontends/introduction/","title":"\ud83e\udde9 Micro Frontends: Introduction","text":"<p>Micro Frontends is an architectural style where a frontend application is divided into smaller, independently deployable parts.</p>"},{"location":"micro-frontends/introduction/#benefits","title":"Benefits","text":"<ul> <li>Independent deployments</li> <li>Technology-agnostic</li> <li>Scalable development</li> </ul> <p>Micro Frontends break down large monolithic applications into manageable modules that can be developed, deployed, and maintained separately. This approach enables teams to work on different parts of the application independently, speeding up development and reducing bottlenecks.</p>"},{"location":"micro-frontends/module-federation/","title":"Micro Frontends: Module Federation","text":"<p>Module Federation is a webpack feature that allows sharing code between multiple applications at runtime.</p> <p>Module Federation is a webpack feature that allows sharing code between multiple applications at runtime, making it a key enabler for Micro Frontends.</p>"},{"location":"micro-frontends/module-federation/#why-use-module-federation","title":"Why Use Module Federation?","text":"<ul> <li>Share code dynamically without redeploying the entire application</li> <li>Enable independent deployments</li> <li>Reduce duplication of shared libraries</li> </ul>"},{"location":"micro-frontends/module-federation/#setting-up-module-federation","title":"Setting Up Module Federation","text":"<ol> <li> <p>Install required dependencies:</p> <pre><code>pnpm add webpack module-federation-plugin\n</code></pre> </li> <li> <p>Configure <code>webpack.config.js</code>:</p> <pre><code>const ModuleFederationPlugin =\n  require(\"webpack\").container.ModuleFederationPlugin;\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"app1\",\n      remotes: {\n        app2: \"app2@http://localhost:3002/remoteEntry.js\",\n      },\n      shared: {\n        react: { singleton: true },\n        \"react-dom\": { singleton: true },\n      },\n    }),\n  ],\n};\n</code></pre> </li> </ol>"},{"location":"micro-frontends/module-federation/#example-usage","title":"Example Usage","text":"<p>In your main application (host):</p>"},{"location":"micro-frontends/module-federation/#micro-frontends-shared-state-in-micro-frontends","title":"Micro Frontends: Shared State in Micro Frontends","text":"<p>Sharing state across Micro Frontends can be achieved using libraries like Redux, Zustand, or even custom context solutions.</p>"},{"location":"micro-frontends/module-federation/#approaches-to-shared-state","title":"Approaches to Shared State","text":"<ol> <li> <p>Shared Redux Store:</p> </li> <li> <p>Use a single Redux store shared across applications.</p> </li> <li> <p>Event-Based Communication:</p> </li> <li> <p>Use custom events to communicate between different Micro Frontends.</p> </li> <li> <p>Shared Context Providers:</p> </li> <li>Create a shared context provider that can be consumed by different Micro Frontends.</li> </ol> Example<pre><code>import { createContext, useContext } from \"react\";\n\nconst GlobalStateContext = createContext();\n\nexport function GlobalStateProvider({ children }) {\n  const state = { user: { name: \"John Doe\" } };\n\n  return (\n    &lt;GlobalStateContext.Provider value={state}&gt;\n      {children}\n    &lt;/GlobalStateContext.Provider&gt;\n  );\n}\n\nexport function useGlobalState() {\n  return useContext(GlobalStateContext);\n}\n</code></pre>"},{"location":"micro-frontends/shared-state/","title":"Micro Frontends: Shared State in Micro Frontends","text":"<p>Sharing state across Micro Frontends can be achieved using libraries like Redux or custom state management solutions.</p> <p>Managing shared state across micro frontends is crucial for ensuring consistent user experience and data flow. Sharing state can be tricky because each micro frontend is typically built as an isolated, independent module. Below are strategies and tools to help achieve shared state management in a micro frontend architecture.</p>"},{"location":"micro-frontends/shared-state/#strategies-for-sharing-state","title":"\u2699\ufe0f Strategies for Sharing State","text":""},{"location":"micro-frontends/shared-state/#1-global-event-bus","title":"1. Global Event Bus","text":"<p>A global event bus allows micro frontends to communicate through events. This is a decoupled approach where state is not directly shared, but events trigger actions in different micro frontends.</p> Example<pre><code>// Event Bus Implementation\nconst eventBus = {\n  events: {},\n  subscribe(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  },\n  publish(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach((callback) =&gt; callback(data));\n    }\n  },\n};\n</code></pre> Usage<pre><code>// Micro Frontend 1 (Publisher)\neventBus.publish(\"USER_LOGIN\", { userId: 1 });\n\n// Micro Frontend 2 (Subscriber)\neventBus.subscribe(\"USER_LOGIN\", (data) =&gt; {\n  console.log(\"User logged in:\", data.userId);\n});\n</code></pre>"},{"location":"micro-frontends/shared-state/#2-shared-state-libraries-redux-zustand","title":"2. Shared State Libraries (Redux, Zustand)","text":"<p>A more robust solution is to use a shared state management library, such as Redux or Zustand, across your micro frontends. This can be done by creating a shared package that all micro frontends can import.</p> \ud83d\udd27 Example with Redux <ol> <li> <p>Create a shared package:</p> <pre><code>pnpm add @reduxjs/toolkit react-redux\n</code></pre> </li> <li> <p>Define a shared store:</p> <pre><code>// shared/store.js\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: { isLoggedIn: false, user: null },\n    reducers: {\n        login: (state, action) =&gt; {\n            state.isLoggedIn = true;\n            state.user = action.payload;\n        },\n        logout: state =&gt; {\n            state.isLoggedIn = false;\n            state.user = null;\n        },\n    },\n});\n\nexport const { login, logout } = userSlice.actions;\n\nexport const store = configureStore({\n    reducer: {\n        user: userSlice.reducer,\n    },\n});\n</code></pre> </li> <li> <p>Use the shared store in micro frontends:</p> <pre><code>// Micro Frontend 1\nimport { store, login } from 'shared/store';\nstore.dispatch(login({ name: 'John Doe' }));\n\n// Micro Frontend 2\nimport { useSelector } from 'react-redux';\nconst user = useSelector(state =&gt; state.user);\nconsole.log(user);\n</code></pre> </li> </ol>"},{"location":"micro-frontends/shared-state/#3-module-federation-with-shared-state","title":"3. Module Federation with Shared State","text":"<p>When using Module Federation, you can share state by exposing a central state management module that other micro frontends can consume.</p> \ud83d\udd27 Example<pre><code>// webpack.config.js (Host App)\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"host\",\n      remotes: {\n        mfe1: \"mfe1@http://localhost:3001/remoteEntry.js\",\n      },\n      shared: {\n        react: { singleton: true },\n        \"react-redux\": { singleton: true },\n      },\n    }),\n  ],\n};\n</code></pre>"},{"location":"micro-frontends/shared-state/#tools-for-shared-state","title":"\ud83e\uddf0 Tools for Shared State","text":"<ul> <li>Redux Toolkit: Simplifies shared state management across micro frontends.</li> <li>Zustand: A lightweight alternative to Redux for managing state.</li> <li>Recoil: State management library by Facebook, ideal for micro frontends.</li> <li>RxJS: Enables reactive state sharing across micro frontends through observables.</li> </ul>"},{"location":"micro-frontends/shared-state/#best-practices","title":"\ud83d\udee0 Best Practices","text":"<ol> <li>Avoid tight coupling: Ensure micro frontends remain independent and only rely on shared state when necessary.</li> <li>Use lazy loading: Load shared state only when required to optimize performance.</li> <li>Handle versioning carefully: Ensure all micro frontends use compatible versions of shared libraries.</li> </ol> <p>By implementing one of these strategies, you can efficiently share state across your micro frontends, improving data consistency and the overall user experience.</p>"},{"location":"security/overview/","title":"Overview","text":"<p>Frontend developers face several security issues when developing applications. While much of the heavy security lifting happens on the backend, the frontend is the first line of defense and often a target for attacks. Here's a breakdown of key security concerns:</p>"},{"location":"security/overview/#1-cross-site-scripting-xss","title":"1. Cross-Site Scripting (XSS)","text":"<ul> <li>What it is: Attackers inject malicious scripts into content that gets executed in a user\u2019s browser.</li> <li>Cause: Unsanitized input/output.</li> <li> <p>Mitigation:</p> <ul> <li>Always escape user input.</li> <li>Use frameworks or libraries that automatically handle DOM sanitization.</li> <li>Implement Content Security Policy (CSP) headers.</li> </ul> </li> </ul>"},{"location":"security/overview/#2-cross-site-request-forgery-csrf","title":"2. Cross-Site Request Forgery (CSRF)","text":"<ul> <li>What it is: Tricks users into making unwanted requests to a web app where they\u2019re authenticated.</li> <li>Cause: Lack of anti-CSRF tokens in requests.</li> <li> <p>Mitigation:</p> <ul> <li>Use anti-CSRF tokens in forms and AJAX requests.</li> <li>Set cookies with <code>SameSite</code> attributes.</li> <li>Avoid relying only on cookies for authentication in state-changing requests.</li> </ul> </li> </ul>"},{"location":"security/overview/#3-insecure-use-of-apis","title":"3. Insecure Use of APIs","text":"<ul> <li>What it is: Exposing sensitive endpoints or not validating responses from third-party APIs.</li> <li>Cause: Lack of input/output validation, poor authentication.</li> <li> <p>Mitigation:</p> <ul> <li>Always validate and sanitize API responses.</li> <li>Do not expose API keys in frontend code.</li> <li>Use HTTPS to prevent interception.</li> </ul> </li> </ul>"},{"location":"security/overview/#4-exposing-sensitive-data-in-the-frontend","title":"4. Exposing Sensitive Data in the Frontend","text":"<ul> <li>What it is: Including secrets (e.g., API keys, credentials) in JavaScript or HTML.</li> <li>Cause: Poor separation of frontend and backend responsibilities.</li> <li> <p>Mitigation:</p> <ul> <li>Keep secrets on the server.</li> <li>Use environment variables and server-side proxies for API access.</li> </ul> </li> </ul>"},{"location":"security/overview/#5-insecure-local-storage-usage","title":"5. Insecure Local Storage Usage","text":"<ul> <li>What it is: Storing sensitive information (e.g., JWTs, tokens) in <code>localStorage</code> or <code>sessionStorage</code>.</li> <li>Cause: Misuse of client-side storage.</li> <li> <p>Mitigation:</p> <ul> <li>Avoid storing sensitive data in <code>localStorage</code>; prefer <code>httpOnly</code> cookies.</li> <li>Encrypt data if it must be stored client-side.</li> </ul> </li> </ul> Quote <p>React apps often use tokens for auth, but <code>localStorage</code> is accessible via JavaScript, and thus vulnerable to XSS.</p> <p>\u274c Don\u2019t:</p> <ul> <li>Store tokens like JWTs in <code>localStorage</code> or <code>sessionStorage</code>.</li> </ul> <p>\u2705 Do:</p> <ul> <li>Use <code>httpOnly</code> cookies for auth tokens (set from the backend).</li> <li>If you must store anything in the client, encrypt it and expire it quickly.</li> </ul>"},{"location":"security/overview/#6-clickjacking","title":"6. Clickjacking","text":"<ul> <li>What it is: Embedding a page in an iframe to trick users into clicking on something they didn\u2019t intend to.</li> <li> <p>Mitigation:</p> <ul> <li>Use <code>X-Frame-Options: DENY</code> or <code>SAMEORIGIN</code> headers.</li> <li>Use Content Security Policy (CSP) <code>frame-ancestors</code> directive.</li> </ul> </li> </ul>"},{"location":"security/overview/#7-dom-based-vulnerabilities","title":"7. DOM-based Vulnerabilities","text":"<ul> <li>What it is: Client-side scripts incorrectly trust data from the DOM, leading to XSS or logic flaws.</li> <li> <p>Mitigation:</p> <ul> <li>Avoid directly manipulating the DOM with unsanitized input.</li> <li>Use secure libraries and frameworks.</li> </ul> </li> </ul>"},{"location":"security/overview/#8-outdated-frontend-dependencies","title":"8. Outdated Frontend Dependencies","text":"<ul> <li>What it is: Using libraries with known vulnerabilities.</li> <li> <p>Mitigation:</p> <ul> <li>Regularly audit dependencies (e.g., <code>npm audit</code>, <code>yarn audit</code>).</li> <li>Use tools like Snyk or Dependabot.</li> <li>Keep dependencies updated.</li> </ul> </li> </ul>"},{"location":"security/overview/#9-improper-input-validation","title":"9. Improper Input Validation","text":"<ul> <li>What it is: Not validating user input on the client side (and assuming the backend will always catch issues).</li> <li> <p>Mitigation:</p> <ul> <li>Implement both client-side and server-side validation.</li> <li>Use regex or input masks where appropriate.</li> </ul> </li> </ul>"},{"location":"security/overview/#10-overly-permissive-cors-settings","title":"10. Overly Permissive CORS Settings","text":"<ul> <li>What it is: Allowing any origin (<code>*</code>) to access resources.</li> <li> <p>Mitigation:</p> <ul> <li>Restrict CORS policies to known, trusted domains.</li> <li>Never allow credentials with <code>Access-Control-Allow-Origin: *</code>.</li> </ul> </li> </ul> Quote <p>CORS is managed by the backend, but React devs often work with APIs.</p> <p>\u2705 Do:</p> <ul> <li>Ensure APIs implement strict CORS policies (not <code>Access-Control-Allow-Origin: *</code>).</li> <li>Avoid leaking credentials with <code>fetch</code> unless intended:</li> </ul> <pre><code>fetch(url, { credentials: 'include' })\n</code></pre>"},{"location":"tools/overview/","title":"Overview","text":"<ul> <li>\ud83d\udd32 NX</li> <li>\ud83d\ude80 Turborepo</li> <li>\ud83d\udce6 Lerna</li> </ul> <ul> <li>NX (\ud83d\udd32): A powerful tool for managing monorepos with integrated build and task running.</li> <li>Turborepo (\ud83d\ude80): Optimized for fast builds and caching in large-scale frontend and backend projects.</li> <li>Lerna (\ud83d\udce6): A simpler tool for managing multiple JavaScript packages in a monorepo.</li> </ul> Summary <ul> <li>NX (\ud83d\udd32): A powerful monorepo management tool with extensive features for frontend and backend development.</li> <li>Turborepo (\ud83d\ude80): Focuses on build performance, caching, and task parallelization in large-scale projects.</li> <li>Lerna (\ud83d\udce6): Simpler tool for managing packages in a monorepo with automatic versioning and publishing.</li> </ul>"},{"location":"tools/overview/#nx-vs-turborepo","title":"NX vs Turborepo","text":"<ul> <li> <p>NX is more focused on managing a <code>monorepo</code> for multiple applications and libraries, with a strong emphasis on scalability and modularity. It's an excellent choice for building a micro-frontend architecture.</p> </li> <li> <p>Turborepo is also a <code>monorepo</code> tool, but it is more focused on build caching and task running across the repository. It is lightweight and can be used with different frontend frameworks, but NX has more built-in features specifically for micro-frontend development, such as code generation, dependency graph, and modular architecture.</p> </li> </ul>"},{"location":"tools/overview/#recommendation","title":"Recommendation","text":"<ul> <li> <p>If you\u2019re working on a large frontend application with micro-frontends, and you want robust tools for managing apps, libraries, and shared code in a monorepo, <code>NX</code> is a great choice.</p> </li> <li> <p>Turborepo can be a good option if your focus is on optimizing build and task running performance, but NX will provide you with more out-of-the-box support for structuring your frontend architecture.</p> </li> </ul>"},{"location":"tools/overview/#in-summary","title":"In Summary","text":"<ul> <li> <p>NX is the tool you should consider if you're looking to build and manage micro-frontends in a <code>monorepo</code> setup.</p> </li> <li> <p>Turborepo is a great alternative if you need build optimization but prefer a simpler setup without as many pre-configured features for micro-frontends.</p> </li> </ul>"},{"location":"tools/usefull-fe-tools/","title":"Usefull Frontend Tools","text":"<p>Here are essential tools and services that benefit frontend developers by simplifying backend integration, similar to BaaS databases:</p>"},{"location":"tools/usefull-fe-tools/#backend-services-for-frontend-developers","title":"Backend Services for Frontend Developers","text":""},{"location":"tools/usefull-fe-tools/#1-baas-platforms","title":"1. BaaS Platforms","text":"<ul> <li>Firebase: Real-time NoSQL database, authentication, hosting, and cloud functions.</li> <li>Supabase: Open-source alternative with PostgreSQL, authentication, and instant APIs.</li> <li>Appwrite: Self-hosted BaaS with databases, authentication, and storage.</li> <li>Backendless: Visual app development with codeless database management and REST APIs.</li> </ul> Reference <ul> <li>Top 13 Backend as a Service (BaaS) Providers</li> <li>Backend-as-a-Service (BaaS) for Modern Web and Mobile Applications</li> <li>BaaS: The Game-Changer for Agile App Development \u2014 Synsoft Global</li> <li>What is Backend as a Service (BaaS)? A Beginner's Guide</li> </ul>"},{"location":"tools/usefull-fe-tools/#2-api-management-tools","title":"2. API Management Tools","text":"<ul> <li>Postman: Test, document, and collaborate on APIs.</li> <li>GraphQL (Apollo Client): Query data efficiently and integrate with frontend frameworks like React.</li> </ul>"},{"location":"tools/usefull-fe-tools/#frontend-development-tools","title":"Frontend Development Tools","text":"<ul> <li>React/Vue.js/Angular: Component-based frameworks for building UIs.</li> <li>Sass: CSS preprocessor for modular and maintainable styles.</li> <li>Axios: HTTP client for API requests.</li> <li>Redux/Recoil: State management libraries for React.</li> </ul> Reference <ul> <li>25 Essential Tools for Front End Developers</li> </ul>"},{"location":"tools/usefull-fe-tools/#devops-workflow-tools","title":"DevOps &amp; Workflow Tools","text":"<ul> <li>Vercel/Netlify: Frontend deployment with serverless functions and CDN.</li> <li>FlyCode: Visually edit frontend text/images and auto-generate Git pull requests.</li> <li>PageSpeed Insights: Optimize performance with Google\u2019s auditing tool.</li> </ul>"},{"location":"tools/usefull-fe-tools/#authentication-security","title":"Authentication &amp; Security","text":"<ul> <li>Auth0/Firebase Auth: Pre-built login systems with social sign-ins.</li> <li>Clerk: User management and authentication SDKs for React/Next.js.</li> </ul>"},{"location":"tools/usefull-fe-tools/#real-time-communication","title":"Real-Time Communication","text":"<ul> <li>Socket.IO: Enable real-time features (chat, notifications).</li> <li>Pusher: APIs for real-time updates and notifications.</li> </ul>"},{"location":"tools/usefull-fe-tools/#data-visualization","title":"Data Visualization","text":"<ul> <li>D3.js: Create dynamic, interactive charts.</li> <li>Chart.js: Simple, responsive graphs for React/Vue.</li> </ul>"},{"location":"tools/usefull-fe-tools/#testing-debugging","title":"Testing &amp; Debugging","text":"<ul> <li>Jest/Cypress: Unit and end-to-end testing for JavaScript.</li> <li>React Developer Tools: Debug React component hierarchies.</li> </ul>"},{"location":"tools/usefull-fe-tools/#key-advantages","title":"Key Advantages","text":"<ul> <li>Rapid prototyping: BaaS tools like Firebase reduce backend setup time.</li> <li>Scalability: Auto-scaling databases and serverless functions.</li> <li>Cost efficiency: Pay-as-you-go pricing models.</li> </ul> <p>For frontend developers, combining BaaS platforms with modern frameworks and workflow tools streamlines full-stack development without deep backend expertise.</p> <ul> <li>Why BaaS is Targeting Frontend Developers</li> </ul>"},{"location":"tools/lerna/intro/","title":"Lerna (\ud83d\udce6)","text":"<p>Lerna is a tool for managing JavaScript projects with multiple packages in a monorepo. It helps with managing dependencies, versioning, and publishing.</p>"},{"location":"tools/lerna/intro/#key-features-of-lerna","title":"Key Features of Lerna","text":"<ul> <li>Package Management: Manage interdependencies between packages in a monorepo.</li> <li>Versioning: Automates versioning of packages across the monorepo.</li> <li>Publishing: Publish packages to npm with a single command.</li> </ul>"},{"location":"tools/lerna/intro/#example-setup","title":"Example Setup","text":"<p>To get started with Lerna:</p> <pre><code>npx lerna init\nlerna bootstrap\n</code></pre> <p>Lerna is another tool that is commonly used for managing monorepos, but it\u2019s slightly different from tools like NX and Turborepo. While Lerna focuses on managing JavaScript projects within a monorepo, its feature set is less opinionated about structure and more focused on managing dependencies and versioning.</p> <ul> <li>Lerna is all about managing packages in a monorepo.</li> </ul>"},{"location":"tools/nx/nx-commands/","title":"NX Commands","text":"<pre><code>npm install -g nx\n\nnx --version\n\nwhich nx  # macOS/Linux\nwhere nx  # Windows\n</code></pre> <p>The Nx CLI provides many commands. They are organized here into commands that:</p> <ul> <li>Modify Code</li> <li>Run Tasks</li> <li>Display Information</li> <li>Integrate with Nx Cloud</li> </ul> Modify Code <pre><code># init - Adds Nx to any type of workspace. It installs nx, creates an nx.json configuration file and optionally sets up remote caching.\nnx init\n\n# add - Install a plugin and initialize it.\nnx add my-plugin\n\n# generate - Runs a generator that creates and/or modifies files based on a generator from a plugin.\nnx generate @nx/react:component libs/my-lib/src/lib/my-component\n</code></pre>"},{"location":"tools/nx/nx-commands/#reference","title":"Reference","text":"<ul> <li>Official Commands: nx commands</li> <li>Intro</li> <li>Installation globally</li> </ul>"},{"location":"tools/nx/setup/","title":"NX (\ud83d\udd32)","text":"<p>NX is a powerful set of tools designed for managing monorepos. It allows you to organize multiple applications and libraries in a single repository and is highly optimized for frontend and backend projects.</p>"},{"location":"tools/nx/setup/#key-features-of-nx","title":"Key Features of NX","text":"<ul> <li>Monorepo Management: Easily manage multiple apps and libraries in the same repository.</li> <li>Code Generation: Generate components, applications, and libraries using CLI commands.</li> <li>Built-in Support: Works well with React, Angular, Next.js, NestJS, and other popular frameworks.</li> <li>Task Running and Caching: Runs tasks efficiently with incremental builds and task caching.</li> </ul>"},{"location":"tools/nx/setup/#example-setup","title":"Example Setup","text":"<p>To get started with NX:</p> <pre><code>npx create-nx-workspace my-workspace\ncd my-workspace\n...\n</code></pre>"},{"location":"tools/nx/setup/#reference","title":"Reference","text":"<ul> <li>Official: NX</li> </ul>"},{"location":"tools/turborepo/setup/","title":"Turborepo (\ud83d\ude80)","text":"<p>Turborepo is a high-performance build system optimized for monorepos. It focuses on speeding up the build process using task parallelization and build caching.</p>"},{"location":"tools/turborepo/setup/#key-features-of-turborepo","title":"Key Features of Turborepo","text":"<ul> <li>Build Caching: Turbo optimizes the build process with caching, so only changed files are rebuilt.</li> <li>Task Running: Supports parallel task execution across multiple projects in the monorepo.</li> <li>Scalability: Handles large-scale projects with ease.</li> </ul>"},{"location":"tools/turborepo/setup/#when-to-consider-turborepo","title":"When to Consider Turborepo:","text":"<p>Turborepo is a powerful tool, but it's more focused on build optimization and task running in a monorepo setup. If you're primarily looking for a tool that helps optimize builds and run tasks in a monorepo, Turborepo is an excellent option. However, it doesn\u2019t provide as much out-of-the-box support for organizing and managing micro-frontend architecture specifically.</p>"},{"location":"tools/turborepo/setup/#why-you-might-choose-turborepo","title":"Why You Might Choose Turborepo:","text":"<ul> <li> <p>Simple monorepo: If you only need a tool for task running, build caching, and optimizing your monorepo setup (but you don\u2019t need advanced features like code generation or dependency graph management), Turborepo is a good choice.</p> </li> <li> <p>Build performance: If your main focus is on fast builds and efficient task running across multiple apps in a monorepo, Turborepo will do a great job, especially with its caching features.</p> </li> </ul> <p>However, if you want to structure your micro-frontends in a way that\u2019s easy to scale and maintain with good development practices, NX is a more feature-complete solution for this purpose.</p>"},{"location":"tools/turborepo/setup/#summary","title":"Summary","text":"<ol> <li> <p>Use NX if you are a beginner to micro-frontends:</p> <ul> <li>Out-of-the-box support for monorepos, micro-frontends, dependency management, code sharing, and building/testing multiple apps in the same repo.</li> <li>Built-in tools to help you scale and organize your micro-frontend projects.</li> <li>Excellent documentation and community support to help you get started easily.</li> </ul> </li> <li> <p>Use Turborepo if you just need build optimization:</p> <ul> <li>If your main concern is fast, optimized builds and task running in a monorepo and you don\u2019t need as much structure around your micro-frontend architecture, Turborepo can be a good option.</li> <li>It\u2019s great for optimizing the build process and caching, but it doesn\u2019t offer the same level of micro-frontend management as NX.</li> </ul> </li> </ol>"},{"location":"tools/turborepo/setup/#final-suggestion","title":"Final Suggestion:","text":"<p>Start with NX. It provides a more complete, beginner-friendly experience for building and scaling micro-frontends, with powerful tools to manage apps and libraries in a monorepo. You can always experiment with Turborepo later if you need more advanced build optimization.</p>"},{"location":"tools/turborepo/setup/#reference","title":"Reference","text":"<ul> <li>Official: turbo</li> </ul>"}]}